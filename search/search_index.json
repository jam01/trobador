{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"extensible jsonnet transformations","text":""},{"location":"#xtrasonnet-is-an-extensible-jsonnet-based-data-transformation-engine-for-java-or-any-jvm-based-language","title":"xtrasonnet is an extensible, jsonnet-based, data transformation engine for Java or any JVM-based language.","text":""},{"location":"#xtrasonnet-is-an-extension-of-databricks-sjsonnet-a-scala-implementation-of-googles-jsonnet-xtrasonnet-enables-extensibility-adds-support-for-data-formats-other-than-json-and-adds-data-transformation-facilities-through-the-xtr-library-and-some-additions-to-the-jsonnet-language-itself","title":"xtrasonnet is an extension of databricks' sjsonnet, a Scala implementation of Google's jsonnet. xtrasonnet enables extensibility, adds support for data formats other than JSON, and adds data transformation facilities through the <code>xtr</code> library and some additions to the jsonnet language itself.","text":"<pre><code>{\n    \"message\": \"hello, world!\"\n}\n</code></pre>              \u27a1          <pre><code>/** xtrasonnet\ninput payload application/json\noutput application/xml\n*/\n{\n    root: {\n        msg: payload.message,\n        at: xtr.datetime.now()\n    }\n}\n</code></pre>          \u27a1      <pre><code>&lt;?xml version='1.0' encoding='UTF-8'?&gt;\n&lt;root&gt;\n    &lt;msg&gt;hello, world!&lt;/msg&gt;\n    &lt;at&gt;2022-08-14T00:19:35.731362Z&lt;/at&gt;\n&lt;/root&gt;\n</code></pre>"},{"location":"#how-extensible","title":"How extensible?","text":"<p>xtrasonnet has two points of extensibility:</p> <ul> <li>Custom functions: users can write native (e.g.: Java or Scala) functions as a <code>Library</code> and utilize them from their transformation code.</li> <li>Any* data format: users can write a custom <code>DataFormatPlugin</code> and transform from/to a given data format.</li> </ul> <p>* Any format that can be expressed as jsonnet elements.</p>"},{"location":"#what-kind-of-additions-to-the-jsonnet-language","title":"What kind of additions to the jsonnet language?","text":"<p>There are two main additions motivated to facilitate data transformation applications:</p>"},{"location":"#null-safe-select","title":"Null-safe select <code>?.</code>","text":"<p>This allows developers to select, and chain, properties arbitrarily without testing existence.</p> <pre><code>local myObj = {\n    keyA: { first: { second: 'value' } },\n    keyB: { first: { } }\n};\n\n{\n    a: myObj?.keyA?.first?.second,\n    b: myObj?.keyB?.first?.second,\n    c: myObj?.keyC?.first?.second\n}\n</code></pre> <p>\u27a1</p> <pre><code>{\n    a: 'value',\n    b: null,\n    c: null\n}\n</code></pre>"},{"location":"#null-coalescing-operator","title":"Null coalescing operator <code>??</code>","text":"<p>This allows developers to tersely test for <code>null</code> and provide a default value. For example</p> <pre><code>local myObj = {\n    keyA: { first: { second: 'value' } },\n    keyB: { first: { } }\n};\n\n{\n    a: myObj?.keyA?.first?.second,\n    b: myObj?.keyB?.first?.second ?? 'defaultB',\n    c: myObj?.keyC?.first?.second ?? 'defaultC'\n}\n</code></pre> <p>\u27a1</p> <pre><code>{\n    a: 'value',\n    b: 'defaultB',\n    c: 'defaultC'\n}\n</code></pre>"},{"location":"camel/","title":"Camel xtrasonnet Language","text":"<p>Since Camel 3.20</p> <p>The Camel xtrasonnet component enables the use xtrasonnet transformations as Expressions or Predicates in the DSL.</p>"},{"location":"camel/#getting-started","title":"Getting started","text":"<p>Add the following maven dependency</p> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.github.jam01&lt;/groupId&gt;\n  &lt;artifactId&gt;camel-xtrasonnet&lt;/artifactId&gt;\n  &lt;version&gt;0.6.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>and simply create an xtrasonnet expression:</p> <pre><code>import static io.github.jam01.camel.builder.XtrasonnetBuilder.xtrasonnet;\n\nxtrasonnet(myXtrasonnet)\n</code></pre>"},{"location":"camel/#examples","title":"Examples","text":"<p>Here is a simple example using a xtrasonnet expression as a predicate in a Message Filter, it will filter messages if any element in <code>lineItems</code> is over 100.</p> <pre><code>// lets route if a line item is over $100\nfrom(\"direct:filter\")\n    .filter(xtrasonnet(\"xtr.arrays.any(payload.lineItems, function(item) item &gt; 100)\"))\n    .to(\"mock:result\");\n</code></pre> <p>And the XML DSL:</p> <pre><code>&lt;route id=\"xml-filter\"&gt;\n    &lt;from uri=\"direct:xml-filter\"/&gt;\n    &lt;filter&gt;\n        &lt;language language=\"xtrasonnet\"&gt;\n            xtr.arrays.any(payload.lineItems, function(item) item &gt; 100)\n        &lt;/language&gt;\n        &lt;to uri=\"mock:xml-result\"/&gt;\n    &lt;/filter&gt;\n&lt;/route&gt;\n</code></pre> <p>Here is an example of a simple xtrasonnet expression in a transformation EIP. </p> <pre><code>from(\"direct:transform\")\n    .transform(xtrasonnet(\"payload.lineItems\", String.class)\n        .bodyMediaType(MediaTypes.APPLICATION_XML)\n        .outputMediaType(MediaTypes.APPLICATION_JSON))\n    .to(\"mock:result\");\n</code></pre> <p>And the XML DSL:</p> <pre><code>&lt;route id=\"xml-transform\"&gt;\n    &lt;from uri=\"direct:xml-transform\"/&gt;\n    &lt;setProperty name=\"CamelXtrasonnetBodyMediaType\"&gt;&lt;constant&gt;application/xml&lt;/constant&gt;&lt;/setProperty&gt;\n    &lt;setProperty name=\"CamelXtrasonnetOutputMediaType\"&gt;&lt;constant&gt;application/json&lt;/constant&gt;&lt;/setProperty&gt;\n    &lt;setProperty name=\"CamelXtrasonnetResultType\"&gt;&lt;constant&gt;java.lang.String&lt;/constant&gt;&lt;/setProperty&gt;\n    &lt;transform&gt;\n        &lt;language language=\"xtrasonnet\"&gt;payload.lineItems&lt;/language&gt;\n    &lt;/transform&gt;\n    &lt;to uri=\"mock:xml-result\"/&gt;\n&lt;/route&gt;\n</code></pre>"},{"location":"camel/#specifying-result-type","title":"Specifying result type","text":"<p>The xtrasonnet expression will return a <code>io.github.jam01.xtrasonnet.document.Document</code> by default. The document preserves the content type metadata along with the contents of the result of the transformation. In predicates, however, the <code>Document</code> will be automatically unwrapped and the boolean content will be returned. Similarly any time you want the content in a specific type, like a String, you have to instruct the xtrasonnet to do so.</p> <p>In Java DSL:</p> <pre><code>xtrasonnet(\"payload.foo\", String.class)\n</code></pre> <p>In XML DSL you use <code>CamelXtrasonnetResultType</code> as an exchange property or message header to provide a fully qualified classname:</p> <pre><code>&lt;setProperty name=\"CamelXtrasonnetResultType\"&gt;&lt;constant&gt;java.lang.String&lt;/constant&gt;&lt;/setProperty&gt;\n&lt;language language=\"xtrasonnet\"&gt;payload.foo&lt;/language&gt;\n</code></pre> <p>Note</p> <p>If you wanted to specify result type through an exchange property or message header in the Java DSL, you can utilize the values in <code>XtrasonnetConstants</code>.</p> <p>If the expression results in an Array, or an Object, you can instruct the expression to return you <code>List.class</code> or <code>Map.class</code>, respectively. However, the output media type must be <code>application/x-java-object</code> (default).</p> <p>Note</p> <p>The default <code>Document</code> object is useful in situations where there are intermediate transformation steps, and so retaining the content metadata through a route execution is valuable.</p>"},{"location":"camel/#specifying-media-types","title":"Specifying media types","text":"<p>A few options are provided for specifying the body and output media types. The xtrasonnet expression will look for a body media type in the following order:</p> <ol> <li>If the body is a <code>Document</code>, it will use the metadata in the object</li> <li>If the <code>bodyMediaType()</code> builder method was used, it will use its value</li> <li>A <code>\"CamelXtrasonnetBodyMediaType\"</code> exchange property or message header</li> <li>A <code>\"Content-Type\"</code> message header</li> <li>The xtrasonnet Header payload input media type directive</li> <li><code>application/x-java-object</code></li> </ol> <p>And for output media type:</p> <ol> <li>If the <code>outputMediaType()</code> builder method was used, it will use its value</li> <li>A <code>\"CamelXtrasonnetBodyMediaType\"</code> exchange property or message header</li> <li>The xtrasonnet Header output media type directive</li> <li><code>application/x-java-object</code></li> </ol> <p>Note</p> <p>If you wanted to specify media types through an exchange property or message header in the Java DSL, you can utilize the values in <code>XtrasonnetConstants</code>.</p>"},{"location":"camel/#cml-library","title":"cml Library","text":"<p>The Camel xtrasonnet component adds the following xtrasonnet functions that can be used to access the exchange:</p> Function Argument Type Description cml.properties property key String Lookup a property using the Properties component (property placeholder) cml.header header name String Lookup a message header cml.exchangeProperty property key String Lookup an exchange property <p>Here's an example showing some of these functions in use:</p> <pre><code>from(\"direct:cml\")\n    .setBody(xtrasonnet(\"'hello ' + cml.properties('toGreet')\", String.class))\n    .to(\"mock:result\");\n</code></pre> <p>And the XML DSL:</p> <pre><code>&lt;route id=\"xml-cml\"&gt;\n    &lt;from uri=\"direct:xml-cml\"/&gt;\n    &lt;setProperty name=\"CamelXtrasonnetResultType\"&gt;&lt;constant&gt;java.lang.String&lt;/constant&gt;&lt;/setProperty&gt;\n    &lt;setBody&gt;\n        &lt;language language=\"xtrasonnet\"&gt;'hello ' + cml.properties('toGreet')&lt;/language&gt;\n    &lt;/setBody&gt;\n    &lt;to uri=\"mock:xml-result\"/&gt;\n&lt;/route&gt;\n</code></pre>"},{"location":"camel/#expression-from-resource","title":"Expression from resource","text":"<p>You can externalize the script and have Camel load it from a resource such as <code>\"classpath:\"</code>, <code>\"file:\"</code>, or <code>\"http:\"</code>.</p> <p>This is done using the following syntax: <code>\"resource:scheme:location\"</code>, e.g.: to refer to a file on the classpath you can do:</p> <pre><code>from(\"direct:resource\")\n    .setHeader(\"myHeader\", xtrasonnet(\"resource:classpath:myXtrasonnet.xtr\", String.class))\n    .to(\"mock:result\")\n</code></pre>"},{"location":"cli/","title":"Cli","text":"<p>under construction...</p>"},{"location":"header/","title":"Header","text":"<p>The xtrasonnet header is a regular jsonnet comment of the following form:</p> <pre><code>/** xtrasonnet\ninput payload application/json\noutput application/xml\n\n// this is a comment\npreserveOrder=false\n*/\n</code></pre>"},{"location":"header/#input-directives","title":"Input directives","text":"<p>The input directives signal to xtrasonnet what the expected media types are at design time for given inputs. For more information about media types see the section on data formats.</p> <p>The <code>payload</code> name is reserved for the \"main\" transformation input. All other inputs would have custom names.</p> <p>If a given input to xtrasonnet is of an explicit media type at runtime, the header directive will be ignored.</p>"},{"location":"header/#output-directive","title":"Output directive","text":"<p>The output directive signals to xtrasonnet the desired media type, at design time, to output. For more information about media types see the section on data formats.</p> <p>If programmatically, an explicit output media type is specified, the header directive will be ignored.</p>"},{"location":"header/#comments","title":"Comments","text":"<p>Comments within the xtrasonnet header must start with two slashes <code>//</code>, otherwise they will be treated as unrecognized directives or options.</p>"},{"location":"header/#preserve-order","title":"Preserve order","text":"<p>Developers may disregard the order of elements in <code>Objects</code> which may speed up execution. </p> <p>Default value is <code>true</code>.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#as-a-dependency","title":"As a dependency","text":""},{"location":"installation/#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.jam01&lt;/groupId&gt;\n    &lt;artifactId&gt;xtrasonnet&lt;/artifactId&gt;\n    &lt;version&gt;0.6.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"installation/#gradle","title":"Gradle","text":"<pre><code>implementation \"io.github.jam01:xtrasonnet:0.6.1\"\n</code></pre>"},{"location":"installation/#sbt","title":"sbt","text":"<pre><code>libraryDependencies += \"io.github.jam01\" % \"xtrasonnet\" % \"0.6.1\"\n</code></pre>"},{"location":"logging/","title":"Logging","text":"<p>Some of xtrasonnet dependencies leverage Log4J directly, instead of utilizing the more standard SLF4J framework. In order to provide a standard logging experience, the xtrasonnet library includes the <code>log4j-to-slf4j</code> bridge in order to forward Log4J events to SLF4J. Applications can then bundle any SLF4J logging implementation to process the log events, such as <code>logback</code> for example.</p>"},{"location":"logging/#using-log4j","title":"Using Log4J","text":"<p>If an application intends to use Log4J as the logging implementation, it is required to exclude the <code>log4j-to-slf4j</code> bridge as a transitive dependency of xtrasonnet. In Maven this is done as follows:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.jam01&lt;/groupId&gt;\n    &lt;artifactId&gt;xtrasonnet&lt;/artifactId&gt; &lt;!-- or camel-xtrasonnet --&gt;\n    &lt;version&gt;0.6.1&lt;/version&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n            &lt;artifactId&gt;log4j-to-slf4j&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"playground/","title":"Playground","text":"Input xtrasonnet Output"},{"location":"programmatic/","title":"Using xtrasonnet programmatically","text":"<p>Once you've included the xtrasonnet dependency in your classpath, you can create a <code>Transformer</code> object to evaluate a jsonnet transformation. Here's a simple JSON-to-JSON example:</p> <pre><code>var myJsonnet = \"\"\"\n            {\n                firstKey: payload.key1,\n                secondKey: payload.key2\n            }\"\"\";\nvar myTransformer = new Transformer(myJsonnet);\n\n\n// transform our input when it's available\nvar myPayload = \"\"\"\n        { \n            \"key1\": \"value1\",\n            \"key2\": \"value2\"\n        }\"\"\";\nvar output = myTransformer.transform(myPayload);\n\n\n// the expected results\nassert output.equals(\"\"\"\n            {\"firstKey\":\"value1\",\"secondKey\":\"value2\"}\"\"\");\n</code></pre>"},{"location":"programmatic/#fine-tuning-the-transformer","title":"Fine tuning the transformer","text":"<p>The <code>Transformer</code> class requires at least the jsonnet transformation template you wish the evaluate, but developers can further control the transformation behavior by passing more arguments, here's an extended example using a <code>TransformerBuilder</code>:</p> <pre><code>var myTransformer = Transformer.builder(myJsonnet)\n        .withInputNames(\"second\", \"third\") // (1)\n        .withLibrary(myCustomLib) // (2)\n        .extendPlugins((plugins) -&gt; plugins.add(myCustomPlugin)) // (3)\n        .build();\n</code></pre> <ol> <li>Signal to the transformer to expect inputs other than the <code>payload</code> input</li> <li>Extend the available functions with a custom <code>Library</code></li> <li>Extend the supported data formats with a custom <code>DataFormatPlugin</code></li> </ol>"},{"location":"programmatic/#fine-tuning-the-transformation","title":"Fine tuning the transformation","text":"<p>Developers can also exert more control on the behavior of the transformation at the point they're ready to evaluate it, by passing more arguments to the <code>transform</code> method. To do so we leverage <code>Document</code> and <code>MediaType</code> objects:</p> <pre><code>OutputStream output = myTransformer.transform(\n        Document.of(myInput, MediaTypes.APPLICATION_JSON), // (1)\n        Map.of(\"second\", mySecInput, \"third\", myThirdInput), // (2)\n        MediaTypes.APPLICATION_XML, // (3)\n        OutputStream.class); // (4)\n</code></pre> <ol> <li>A <code>Document</code> object with the input content and the media type that describes its format.</li> <li>A <code>java.util.Map</code> containing the inputs, other than the <code>payload</code> input, that the transformation expects.</li> <li>The <code>MediaType</code> object representing the output format to be returned, if supported.</li> <li>The type of the object to be returned, if supported.</li> </ol>"},{"location":"programmatic/#header-present","title":"Header present","text":"<p>If the transformation jsonnet includes an xtrasonnet header the behavior to be expected is as follows:</p> <ul> <li>If the <code>.transform(String)</code> method is used, a payload document is created internally with media type <code>MediaTypes.UNKNOWN</code> (equivalent to <code>unknown/unknown</code>), and the requested output set to <code>MediaTypes.ANY</code> (equivalent to <code>*/*</code>). Then the following rules apply. </li> <li>If the <code>MediaType</code> of any given input is <code>MediaTypes.UNKNOWN</code> (equivalent to <code>unknown/unknown</code>) then the header will be queried for a matching input directive. If the header does not specify, then the transformer will attempt to read it as JSON.</li> <li>If the requested output <code>MediaType</code> is <code>MediaTypes.ANY</code> (equivalent to <code>*/*</code>) then the header will be queried for an output directive. If the header does not specify one, then the transformer will attempt to write the output as JSON.</li> </ul>"},{"location":"dataformats/","title":"Data formats","text":"<p>The mechanism xtrasonnet utilizes to support multiple data formats is influenced by REST and HTTP.</p>"},{"location":"dataformats/#media-types-as-identifiers","title":"Media types as identifiers","text":"<p>REST's Uniform Interface constraint allows for the possibility of a resource to be represented in multiple data formats. In HTTP the mechanism for identifying those formats is a media type string. This can be observed in action by requesting different media types for a given resource:</p> <pre><code>GET /my-resource\nAccept: application/json\n</code></pre> <p>or if we prefer an XML document...</p> <pre><code>GET /my-resource\nAccept: application/xml\n</code></pre> <p>These two requests would return a JSON and XML document, respectively, if the server could indeed represent <code>/my-resource</code> in both formats.</p>"},{"location":"dataformats/#writing-json","title":"Writing JSON","text":"<p>xtrasonnet's mechanism is similar to HTTP's. Developers can use media types to signal to the transformer which format to output. Because xtrasonnet is based on jsonnet, the canonical representation of any transformation is JSON; this means transformation results can always be represented as JSON.</p> <p>Standalone <pre><code>/**\noutput application/json\n*/\n[\n  { color: 'blue', type: 'bus' },\n  { color: 'yellow', type: 'truck' }\n]\n</code></pre></p> <p>Programmatically <pre><code>var myJsonnet = \"\"\"\n            [\n              { color: 'blue', type: 'bus' },\n              { color: 'yellow', type: 'truck' }\n            ]\"\"\";\nvar myTransformer = new Transformer(myJsonnet);\n\nvar output = myTransfomer.transform(Documents.Null, \n        Collections.emptyMap,\n        MediaTypes.APPLICATION_JSON,\n        String.class);\n</code></pre></p>"},{"location":"dataformats/#writing-other-formats","title":"Writing other formats","text":"<p>Yet, based on the structure of the resulting JSON, other data formats may be possible. For example, the resulting JSON of the previous transformation</p> <pre><code>[\n  { \"color\": \"blue\", \"type\": \"bus\" },\n  { \"color\": \"yellow\", \"type\": \"truck\" }\n]\n</code></pre> <p>can be considered to be the equivalent of the following CSV</p> <pre><code>color,type\nblue,bus\nyellow,truck\n</code></pre> <p>and because xtrasonnet supports CSV out of the box, we can request it</p> <p>Standalone <pre><code>/**\noutput text/csv\n*/\n[\n  { color: 'blue', type: 'bus' },\n  { color: 'yellow', type: 'truck' }\n]\n</code></pre></p> <p>Programmatically <pre><code>var myJsonnet = \"\"\"\n            [\n              { color: 'blue', type: 'bus' },\n              { color: 'yellow', type: 'truck' }\n            ]\"\"\";\nvar myTransformer = new Transformer(myJsonnet);\n\nvar output = myTransfomer.transform(Documents.Null, \n        Collections.emptyMap,\n        MediaTypes.TEXT_CSV,\n        String.class);\n</code></pre></p> <p>which would result in the following output</p> <pre><code>color,type\nblue,bus\nyellow,truck\n</code></pre>"},{"location":"dataformats/#reading-input","title":"Reading input","text":"<p>Similarly, it's possible for xtrasonnet to read JSON or other formats if they follow the particular structure supported by the available data format plugins. For example, to transform the previous CSV result back to JSON...</p> <p>Standalone <pre><code>/**\ninput text/csv\noutput application/json\n*/\npayload\n</code></pre></p> <p>Programmatically <pre><code>var myJsonnet = \"payload\";\nvar myTransformer = new Transformer(myJsonnet);\n\nvar myInput = \"\"\"\n            color,type\n            blue,bus\n            yellow,truck\n            \"\"\";\n\nvar output = myTransfomer.transform(Document.of(myInput, MediaTypes.TEXT_CSV), \n        Collections.emptyMap,\n        MediaTypes.APPLICATION_JSON,\n        String.class);\n</code></pre></p> <p>which would result in </p> <pre><code>[\n  { \"color\": \"blue\", \"type\": \"bus\" },\n  { \"color\": \"yellow\", \"type\": \"truck\" }\n]\n</code></pre>"},{"location":"dataformats/#parameters-as-instructions","title":"Parameters as instructions","text":"<p>In order to further control how the data format plugins read and write data, xtrasonnet leverages media type parameters. For example, in order to write the previous CSV example without a header line the following media type can be used</p> <p>Standalone <pre><code>/**\noutput text/csv; header=absent\n*/\n[\n  { color: 'blue', type: 'bus' },\n  { color: 'yellow', type: 'truck' }\n]\n</code></pre></p> <p>Programmatically <pre><code>var myJsonnet = \"\"\"\n            [\n              { color: 'blue', type: 'bus' },\n              { color: 'yellow', type: 'truck' }\n            ]\"\"\";\nvar myTransformer = new Transformer(myJsonnet);\n\nvar output = myTransfomer.transform(Documents.Null, \n        Collections.emptyMap,\n        MediaTypes.TEXT_CSV.withParameter(\"header\", \"absent\"),\n        String.class);\n</code></pre></p> <p>which would result in the following output</p> <pre><code>blue,bus\nyellow,truck\n</code></pre> <p>Warning</p> <p>The CSV example above uses a parameter that is part of the <code>text/csv</code> IANA media type registration. Not all parameters used by the xtrasonnet data format plugins are registered.</p>"},{"location":"dataformats/csv/","title":"Comma Separated Values","text":""},{"location":"dataformats/csv/#supported-mediatypes","title":"Supported MediaTypes","text":"<ul> <li><code>text/csv</code></li> <li><code>application/csv</code></li> </ul>"},{"location":"dataformats/csv/#reader-parameters","title":"Reader parameters","text":""},{"location":"dataformats/csv/#quotechar","title":"<code>quotechar</code>","text":"<p>The character for identifying quoted strings.</p>"},{"location":"dataformats/csv/#separator","title":"<code>separator</code>","text":"<p>The character for identifying separate values.</p>"},{"location":"dataformats/csv/#escapechar","title":"<code>escapechar</code>","text":"<p>The character for identifying an escape sequence.</p>"},{"location":"dataformats/csv/#header","title":"<code>header</code>","text":"<p>Whether there is a header line present. </p> <p>Allowed values are <code>present</code> or <code>absent</code>.</p> <p>If marked as present the plugin will read each line into a jsonnet <code>Object</code> where the keys are the corresponding values of the header line, otherwise will read each line into an <code>Array</code> of <code>String</code>.</p>"},{"location":"dataformats/csv/#columns","title":"<code>columns</code>","text":"<p>The columns names to use if a header line is not present in the input and jsonnet <code>Object</code>s are required.</p> <p>The value must be a comma <code>','</code> separated list of column names. Alternatively, if the <code>separator</code> parameter is also present that character should be used.</p>"},{"location":"dataformats/csv/#writer-parameters","title":"Writer parameters","text":""},{"location":"dataformats/csv/#quotechar_1","title":"<code>quotechar</code>","text":"<p>The character for quoting strings if necessary.</p>"},{"location":"dataformats/csv/#separator_1","title":"<code>separator</code>","text":"<p>The character for separating values.</p>"},{"location":"dataformats/csv/#escapechar_1","title":"<code>escapechar</code>","text":"<p>The character for escaping a character sequence.</p>"},{"location":"dataformats/csv/#header_1","title":"<code>header</code>","text":"<p>Whether to output a header line.</p> <p>Allowed values are <code>present</code> or <code>absent</code>.</p>"},{"location":"dataformats/csv/#columns_1","title":"<code>columns</code>","text":"<p>The columns names to use if the jsonnet to output is an <code>Array</code> of <code>String</code> and the <code>header</code> parameter is also present.</p> <p>The value must be a comma <code>','</code> separated list of column names. Alternatively, if the <code>separator</code> parameter is also present that character should be used.</p>"},{"location":"dataformats/java/","title":"Java Object","text":""},{"location":"dataformats/java/#supported-mediatypes","title":"Supported MediaTypes","text":"<ul> <li><code>application/x-java-object</code></li> <li><code>application/java</code></li> </ul> <p>Warning</p> <p>This format is not supported in the xtrasonnet Playground</p>"},{"location":"dataformats/java/#custom-jacksonjsonmapper","title":"Custom <code>jackson.JsonMapper</code>","text":"<p>xtrasonnet Java Object support is built on top of the popular FasterXML Jackson library. Being a general purpose transformation language some choices are made around Jackson's <code>JsonMapper</code> configuration, such as:</p> <ul> <li><code>enable(MapperFeature.BLOCK_UNSAFE_POLYMORPHIC_BASE_TYPES)</code></li> <li><code>defaultDateFormat(new StdDateFormat())</code> // ISO-8601 for <code>java.util.Date</code></li> </ul> <p>In order to make different configurations or just further customize the mapper, developers can create the <code>DefaultJavaPlugin(JsonMapper)</code> constructor and provide their customized mapper.</p> <pre><code>var myJavaPlugin = new DefaultJavaPlugin(myJsonMapper);\nvar myTransformer = Transformer.builder(myJsonnet)\n    .extendPlugins(plugins -&gt; {\n        plugins.removeIf(plugin -&gt; plugin instanceof DefaultJavaPlugin); // remove the default one\n        plugins.add(0, myJavaPlugin);\n    })\n    .build();\n</code></pre>"},{"location":"dataformats/java/#javautildate-support","title":"<code>java.util.Date</code> support","text":"<p>xtrasonnet defaults (de)serializing <code>Date</code> objects to UTC time, in order to workaround the type's lossy issues. Below is a brief description of the issues with <code>Date</code> that motivate a setting default time zone.</p> <p>Up until Java 8, the only date-time type in Java was <code>java.util.Date</code>. <code>Date</code> represents an instant in time, in UTC. It has the following shortcomings:</p> <ul> <li>No unambiguous way to represent a date-only value; developers are forced to use a <code>Date</code> with its time set to zero.</li> <li>Implicitly (de)serializes with the system-local time zone, even though the type itself doesn't track a time zone.</li> </ul> <p>To illustrate the issues with this type, consider the following scenario:</p> <ol> <li>A <code>new Date()</code> taken at second zero of the year 2023 in a -06:00 server, results in an object with the following data <code>2023-01-01T06:00:00.000+00:00</code></li> <li>serializing such a date in that same server with an ISO-8601 format results in the string <code>2023-01-01T00:00:00.000-06:00</code></li> <li>serializing as a date only value in that same server results in the string <code>2023-01-01</code></li> <li>deserializing that date-only string in a server running in -05:00 would create a <code>Date</code> object with the following data <code>2023-01-01T05:00:00.000+00:00</code></li> <li>deserializing that date-only string in a server running in +01:00 would create a <code>Date</code> object with the following data <code>1999-12-31T23:00:00.000+00:00</code></li> </ol> <p>While (4.) may be OK even with the loss of one hour, (5.) may have some serious consequences.</p> <p>The shortcomings of the <code>Date</code> type lead to the necessity of coordinating Java (de)serialization to use the same time zone; otherwise the resulting <code>Date</code> object risks losing time. For a library like xtrasonet UTC is the only sane time zone default.</p> <p>For more information check out Jon Skeet's All about java.util.Date</p>"},{"location":"dataformats/java/#supported-reader-parameters","title":"Supported reader parameters","text":""},{"location":"dataformats/java/#dateformat","title":"<code>dateformat</code>","text":"<p>The date and time format to use when serializing <code>java.util.Date</code> values as Strings, and deserializing from JSON Strings.</p> <p>The given value must conform to the standard Java Date Format patterns.</p>"},{"location":"dataformats/java/#supported-writer-parameters","title":"Supported writer parameters","text":""},{"location":"dataformats/java/#type","title":"<code>type</code>","text":"<p>The desired output Java object type.</p>"},{"location":"dataformats/java/#dateformat_1","title":"<code>dateformat</code>","text":"<p>The date and time format to use when serializing <code>java.util.Date</code> values as Strings, and deserializing from JSON Strings.</p> <p>The given value must conform to the standard Java Date Format patterns.</p>"},{"location":"dataformats/json/","title":"Javascript Object Notation","text":""},{"location":"dataformats/json/#supported-mediatypes","title":"Supported MediaTypes","text":"<ul> <li><code>application/json</code></li> <li><code>application/*+json</code></li> </ul>"},{"location":"dataformats/json/#supported-writer-parameters","title":"Supported writer parameters","text":""},{"location":"dataformats/json/#fmt","title":"<code>fmt</code>","text":"<p>Instructs the plugin to format or indent the output. </p> <p>Allowed values are <code>true</code> and <code>false</code>.</p>"},{"location":"dataformats/plaintext/","title":"Plain Text","text":"<p>Text that does not contain any formatting command  or directives.</p>"},{"location":"dataformats/plaintext/#supported-mediatypes","title":"Supported MediaTypes","text":"<ul> <li><code>text/plain</code></li> </ul>"},{"location":"dataformats/spreadsheet/","title":"Office OpenXML Spreadsheet","text":"<p>Standardized format for representing spreadsheets, developed by Microsoft.</p>"},{"location":"dataformats/spreadsheet/#supported-mediatypes","title":"Supported MediaTypes","text":"<ul> <li><code>application/vnd.openxmlformats-officedocument.spreadsheetml.sheet</code></li> <li><code>application/vnd.ms-excel</code></li> </ul> <p>Warning</p> <p>At this time only reading Spreadsheet files is supported.</p> <p>Warning</p> <p>This format is not supported in the xtrasonnet Playground</p>"},{"location":"dataformats/spreadsheet/#jsonnet-representation","title":"Jsonnet representation","text":"<p>A spreadsheet such as </p> A B C 1 a1 b1 c1 2 a2 b2 c2 <p>is converted into the following jsonnet </p> <pre><code>{\n    \"Sheet1\": [\n        {\"A\":\"a1\",\"B\":\"b1\",\"C\":\"c1\"},\n        {\"A\":\"a2\",\"B\":\"b2\",\"C\":\"c2\"}\n    ]\n}\n</code></pre> <p>where <code>Sheet1</code> is the name of the spreadsheet sheet.</p>"},{"location":"dataformats/xml/","title":"eXtensible Markup Language","text":""},{"location":"dataformats/xml/#supported-mediatypes","title":"Supported MediaTypes","text":"<ul> <li><code>application/xml</code></li> <li><code>application/*+xml</code></li> </ul>"},{"location":"dataformats/xml/#xtrasonnet-convention","title":"xtrasonnet convention","text":"<p>Representing XML as JSON is not an obvious exercise, but a few conventions exist. Different conventions make different choices about what XML characteristics are important and which aren't, for example how they represent attributes or namespaces if they're kept at all.</p> <p>xtrasonnet's built in XML data format plugin is based on the BadgerFish convention, with some modifications and extensions. There are three conversion modes: <code>simplified</code>, <code>badger</code> (default), and <code>extended</code>.</p> <p>Consider the following XML document:</p> <pre><code>&lt;reports ns=\"http://www.w3.org/2005/Atom\" xmlns:georss=\"http://www.georss.org/georss\"&gt;\n    &lt;entry&gt;\n        &lt;title&gt;A large tree branch is blocking the road&lt;/title&gt;\n        &lt;link rel=\"self\" href=\"http://open311.sfgov.org/dev/V1/reports/637619.xml\"/&gt;\n        &lt;author&gt;&lt;name&gt;John Doe&lt;/name&gt;&lt;/author&gt;\n        &lt;georss:point&gt;40.7111 -73.9565&lt;/georss:point&gt;\n        &lt;category label=\"Damaged tree\" term=\"tree-damage\" scheme=\"https://open311.sfgov.org/dev/V1/categories/006.xml\"&gt;006&lt;/category&gt;\n        &lt;content type=\"xml\" ns=\"http://open311.org/spec/georeport-v1\"&gt;\n            &lt;report_id&gt;637619&lt;/report_id&gt;\n            &lt;status&gt;created&lt;/status&gt;\n            &lt;status_notes /&gt;\n            &lt;policy&gt;The City will inspect and require the responsible party to correct within 24 hours and/or issue a Correction Notice or Notice of Violation of the Public Works Code&lt;/policy&gt;\n        &lt;/content&gt;\n    &lt;/entry&gt;\n    &lt;entry&gt;\n        &lt;title&gt;A large tree branch is blocking the road&lt;/title&gt;\n        &lt;link rel=\"self\" href=\"http://open311.sfgov.org/dev/V1/reports/637620.xml\"/&gt;\n        &lt;author&gt;&lt;name&gt;John Doe&lt;/name&gt;&lt;/author&gt;\n        &lt;georss:point&gt;40.7111 -73.9565&lt;/georss:point&gt;\n        &lt;category label=\"Damaged tree\" term=\"tree-damage\" scheme=\"https://open311.sfgov.org/dev/V1/categories/006.xml\"&gt;006&lt;/category&gt;\n        &lt;content type=\"xml\" ns=\"http://open311.org/spec/georeport-v1\"&gt;\n            &lt;report_id&gt;637620&lt;/report_id&gt;\n            &lt;status&gt;created&lt;/status&gt;\n            &lt;status_notes /&gt;\n            &lt;policy&gt;&lt;![CDATA[The City will inspect and require the responsible party to correct within 24 hours and/or issue a Correction Notice or Notice of Violation of the Public Works Code]]&gt;&lt;/policy&gt;\n        &lt;/content&gt;\n    &lt;/entry&gt;\n&lt;/reports&gt;\n</code></pre>"},{"location":"dataformats/xml/#simplified","title":"simplified","text":"<p>In the simplified mode the following rules apply:</p> <ul> <li>Attributes are ignored; equivalent to <code>exclude=attrs</code></li> <li>XML namespaces are ignored; equivalent to <code>exclude=xmlns</code></li> <li>Elements' name form is their local name; equivalent to <code>nameform=local</code></li> <li>Elements with only children elements result in an <code>Object</code>, with an entry for each child</li> <li>Elements with only text result in a <code>String</code></li> <li>Elements with text and children elements result in an <code>Object</code>, with an entry for each child while ignoring the text</li> <li>Elements with the same name result in an <code>Array</code></li> <li>Empty elements result in <code>Null</code></li> <li>Text fragments are concatenated, those are plain text content and cdata elements</li> <li>Text content is trimmed; equivalent to <code>trimtext=true</code></li> </ul> <pre><code>{\n  \"reports\": {\n    \"entry\": [\n      {\n        \"title\": \"A large tree branch is blocking the road\",\n        \"link\": null,\n        \"author\": {\n          \"name\": \"John Doe\"\n        },\n        \"point\": \"40.7111 -73.9565\",\n        \"category\": \"006\",\n        \"content\": {\n          \"report_id\": \"637619\",\n          \"status\": \"created\",\n          \"status_notes\": null,\n          \"policy\": \"The City will inspect and require the responsible party to correct within 24 hours and/or issue a Correction Notice or Notice of Violation of the Public Works Code\"\n        }\n      },\n      {\n        \"title\": \"A large tree branch is blocking the road\",\n        \"link\": null,\n        \"author\": {\n          \"name\": \"John Doe\"\n        },\n        \"point\": \"40.7111 -73.9565\",\n        \"category\": \"006\",\n        \"content\": {\n          \"report_id\": \"637620\",\n          \"status\": \"created\",\n          \"status_notes\": null,\n          \"policy\": \"The City will inspect and require the responsible party to correct within 24 hours and/or issue a Correction Notice or Notice of Violation of the Public Works Code\"\n        }\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"dataformats/xml/#badger","title":"badger","text":"<p>In the badger mode the following rules apply:</p> <ul> <li>Every element results in an <code>Object</code></li> <li>Elements with the same name result in an <code>Array</code></li> <li>Attributes are included in an <code>_attr</code> entry</li> <li>XML namespaces are included in an <code>_xmlns</code> entry, with the default namespace under a <code>_def</code> key </li> <li>Text content is included in a <code>_text</code> entry</li> <li>Text fragments are concatenated, those are plain text content and cdata elements</li> <li>Text content is trimmed; equivalent to <code>trimtext=true</code></li> <li>Empty elements result in an empty <code>Object</code></li> </ul> <pre><code>{\n  \"reports\": {\n    \"_xmlns\": {\n      \"georss\": \"http://www.georss.org/georss\"\n    },\n    \"_attr\": {\n      \"ns\": \"http://www.w3.org/2005/Atom\"\n    },\n    \"entry\": [\n      {\n        \"title\": {\n          \"_text\": \"A large tree branch is blocking the road\"\n        },\n        \"link\": {\n          \"_attr\": {\n            \"rel\": \"self\",\n            \"href\": \"http://open311.sfgov.org/dev/V1/reports/637619.xml\"\n          }\n        },\n        \"author\": {\n          \"name\": {\n            \"_text\": \"John Doe\"\n          }\n        },\n        \"georss:point\": {\n          \"_text\": \"40.7111 -73.9565\"\n        },\n        \"category\": {\n          \"_attr\": {\n            \"label\": \"Damaged tree\",\n            \"term\": \"tree-damage\",\n            \"scheme\": \"https://open311.sfgov.org/dev/V1/categories/006.xml\"\n          },\n          \"_text\": \"006\"\n        },\n        \"content\": {\n          \"_attr\": {\n            \"type\": \"xml\",\n            \"ns\": \"http://open311.org/spec/georeport-v1\"\n          },\n          \"report_id\": {\n            \"_text\": \"637619\"\n          },\n          \"status\": {\n            \"_text\": \"created\"\n          },\n          \"status_notes\": {},\n          \"policy\": {\n            \"_text\": \"The City will inspect and require the responsible party to correct within 24 hours and/or issue a Correction Notice or Notice of Violation of the Public Works Code\"\n          }\n        }\n      },\n      {\n        \"title\": {\n          \"_text\": \"A large tree branch is blocking the road\"\n        },\n        \"link\": {\n          \"_attr\": {\n            \"rel\": \"self\",\n            \"href\": \"http://open311.sfgov.org/dev/V1/reports/637620.xml\"\n          }\n        },\n        \"author\": {\n          \"name\": {\n            \"_text\": \"John Doe\"\n          }\n        },\n        \"georss:point\": {\n          \"_text\": \"40.7111 -73.9565\"\n        },\n        \"category\": {\n          \"_attr\": {\n            \"label\": \"Damaged tree\",\n            \"term\": \"tree-damage\",\n            \"scheme\": \"https://open311.sfgov.org/dev/V1/categories/006.xml\"\n          },\n          \"_text\": \"006\"\n        },\n        \"content\": {\n          \"_attr\": {\n            \"type\": \"xml\",\n            \"ns\": \"http://open311.org/spec/georeport-v1\"\n          },\n          \"report_id\": {\n            \"_text\": \"637620\"\n          },\n          \"status\": {\n            \"_text\": \"created\"\n          },\n          \"status_notes\": {},\n          \"policy\": {\n            \"_text\": \"The City will inspect and require the responsible party to correct within 24 hours and/or issue a Correction Notice or Notice of Violation of the Public Works Code\"\n          }\n        }\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"dataformats/xml/#extended","title":"extended","text":"<p>In the extended mode the following rules apply:</p> <ul> <li>Every element results in an <code>Object</code></li> <li>Elements with the same name result in an <code>Array</code></li> <li>Attributes are included in an <code>_attr</code> entry</li> <li>XML namespaces are included in an <code>_xmlns</code> entry, with the default namespace under a <code>_def</code> key</li> <li>Plain text content is included in a <code>_text</code> entry</li> <li>CData text is included in a <code>_cdata</code> entry</li> <li>An element's position within its parent is included in an <code>_pos</code> entry, or as a suffix on its name if it's a plain or cdata text</li> <li>Text content is not trimmed; equivalent to <code>trimtext=false</code></li> </ul> <p>Hint</p> <p>Extended mode is recommended in scenarios where mixed content is expected in an element, that is multiple text fragments and child elements. Or if reading and writing XML and it's desirable to keep the structure as identical as possible, since extended mode will keep elements order even if there are arrays, and keep individual text and cdata elements separate. </p> <pre><code>{\n  \"reports\": {\n    \"_xmlns\": {\n      \"georss\": \"http://www.georss.org/georss\"\n    },\n    \"_attr\": {\n      \"ns\": \"http://www.w3.org/2005/Atom\"\n    },\n    \"entry\": [\n      {\n        \"title\": {\n          \"_text1\": \"A large tree branch is blocking the road\",\n          \"_pos\": 1\n        },\n        \"link\": {\n          \"_attr\": {\n            \"rel\": \"self\",\n            \"href\": \"http://open311.sfgov.org/dev/V1/reports/637619.xml\"\n          },\n          \"_pos\": 2\n        },\n        \"author\": {\n          \"name\": {\n            \"_text1\": \"John Doe\",\n            \"_pos\": 1\n          },\n          \"_pos\": 3\n        },\n        \"georss:point\": {\n          \"_text1\": \"40.7111 -73.9565\",\n          \"_pos\": 4\n        },\n        \"category\": {\n          \"_attr\": {\n            \"label\": \"Damaged tree\",\n            \"term\": \"tree-damage\",\n            \"scheme\": \"https://open311.sfgov.org/dev/V1/categories/006.xml\"\n          },\n          \"_text1\": \"006\",\n          \"_pos\": 5\n        },\n        \"content\": {\n          \"_attr\": {\n            \"type\": \"xml\",\n            \"ns\": \"http://open311.org/spec/georeport-v1\"\n          },\n          \"report_id\": {\n            \"_text1\": \"637619\",\n            \"_pos\": 1\n          },\n          \"status\": {\n            \"_text1\": \"created\",\n            \"_pos\": 2\n          },\n          \"status_notes\": {\n            \"_pos\": 3\n          },\n          \"policy\": {\n            \"_text1\": \"The City will inspect and require the responsible party to correct within 24 hours and/or issue a Correction Notice or Notice of Violation of the Public Works Code\",\n            \"_pos\": 4\n          },\n          \"_pos\": 6\n        },\n        \"_pos\": 1\n      },\n      {\n        \"title\": {\n          \"_text1\": \"A large tree branch is blocking the road\",\n          \"_pos\": 1\n        },\n        \"link\": {\n          \"_attr\": {\n            \"rel\": \"self\",\n            \"href\": \"http://open311.sfgov.org/dev/V1/reports/637620.xml\"\n          },\n          \"_pos\": 2\n        },\n        \"author\": {\n          \"name\": {\n            \"_text1\": \"John Doe\",\n            \"_pos\": 1\n          },\n          \"_pos\": 3\n        },\n        \"georss:point\": {\n          \"_text1\": \"40.7111 -73.9565\",\n          \"_pos\": 4\n        },\n        \"category\": {\n          \"_attr\": {\n            \"label\": \"Damaged tree\",\n            \"term\": \"tree-damage\",\n            \"scheme\": \"https://open311.sfgov.org/dev/V1/categories/006.xml\"\n          },\n          \"_text1\": \"006\",\n          \"_pos\": 5\n        },\n        \"content\": {\n          \"_attr\": {\n            \"type\": \"xml\",\n            \"ns\": \"http://open311.org/spec/georeport-v1\"\n          },\n          \"report_id\": {\n            \"_text1\": \"637620\",\n            \"_pos\": 1\n          },\n          \"status\": {\n            \"_text1\": \"created\",\n            \"_pos\": 2\n          },\n          \"status_notes\": {\n            \"_pos\": 3\n          },\n          \"policy\": {\n            \"_cdata1\": \"The City will inspect and require the responsible party to correct within 24 hours and/or issue a Correction Notice or Notice of Violation of the Public Works Code\",\n            \"_pos\": 4\n          },\n          \"_pos\": 6\n        },\n        \"_pos\": 2\n      }\n    ],\n    \"_pos\": 1\n  }\n}\n</code></pre>"},{"location":"dataformats/xml/#reader-parameters","title":"Reader parameters","text":""},{"location":"dataformats/xml/#mode","title":"<code>mode</code>","text":"<p>The xtrasonnet XML to JSON convention to use when reading XML.</p> <p>Allowed values are <code>simplified</code>, <code>badger</code> (default), <code>extended</code>.</p>"},{"location":"dataformats/xml/#textkey","title":"<code>textkey</code>","text":"<p>The key to use for text elements.</p> <p>Default is <code>_text</code>.</p>"},{"location":"dataformats/xml/#attrkey","title":"<code>attrkey</code>","text":"<p>The key to use for attribute elements.</p> <p>Default is <code>_attr</code>.</p>"},{"location":"dataformats/xml/#cdatakey","title":"<code>cdatakey</code>","text":"<p>The key to use for CData elements in <code>extended</code> mode.</p> <p>Default is <code>_cdata</code>.</p>"},{"location":"dataformats/xml/#poskey","title":"<code>poskey</code>","text":"<p>The key to use for element positions in <code>extended</code> mode.</p> <p>Default is <code>_pos</code>.</p>"},{"location":"dataformats/xml/#xmlnsaware","title":"<code>xmlnsaware</code>","text":"<p>Whether to validate and process XML Namespaces as defined by the 1.1 XML specification</p> <p>Allowed values are <code>true</code> (default) and <code>false</code>.</p>"},{"location":"dataformats/xml/#xmlnskey","title":"<code>xmlnskey</code>","text":"<p>The key to use for XML namespace elements.</p> <p>Default is <code>_xmlns</code></p>"},{"location":"dataformats/xml/#xmlns","title":"<code>xmlns.*</code>","text":"<p>XML namespace declarations to reference fully qualified elements independent of the prefix present.</p> <p>Declarations are of the form <code>xmlns.&lt;prefix&gt;=&lt;URI&gt;</code> e.g.: <code>xmlns.soap=\"http://www.w3.org/2003/05/soap-envelope/\"</code>.</p> <p>Any elements found matching the given URI will be implicitly transformed to use the given prefix to facilitate referencing elements that may use arbitrary prefixes.</p> <p>Note</p> <p>If a namespace declaration prefix is being used by a different URI, elements of the non-matching URI will have their prefix \"bumped\" by adding a <code>_n</code> where <code>n</code> is a number that makes the resulting prefix an unique value.</p>"},{"location":"dataformats/xml/#nameform","title":"<code>nameform</code>","text":"<p>The desired form of element names.</p> <p>Allowed values are <code>qname</code> (qualified name) and <code>local</code> (local name, minus domain qualification).</p> <p>Warning</p> <p>If <code>nameform=local</code> and <code>xmlnsaware=false</code> then element names will be a best-effort transformation where the value is the content of the name after the first colon symbol <code>':'</code>, instead of proper XML namespace processing. </p>"},{"location":"dataformats/xml/#trimtext","title":"<code>trimtext</code>","text":"<p>Whether to trim text elements.</p> <p>Allowed values are <code>true</code> (default) and <code>false</code>.</p>"},{"location":"dataformats/xml/#exclude","title":"<code>exclude</code>","text":"<p>Data components to exclude when reading XML.</p> <p>Allowed values are:</p> <ul> <li><code>attrs</code> XML attribute elements</li> <li><code>xmlns</code> XML namespace data</li> </ul>"},{"location":"dataformats/xml/#writer-parameters","title":"Writer parameters","text":""},{"location":"dataformats/xml/#textkey_1","title":"<code>textkey</code>","text":"<p>The key to expect for text elements.</p> <p>Default is <code>_text</code>.</p>"},{"location":"dataformats/xml/#attrkey_1","title":"<code>attrkey</code>","text":"<p>The key to expect for attribute elements.</p> <p>Default is <code>_attr</code>.</p>"},{"location":"dataformats/xml/#cdatakey_1","title":"<code>cdatakey</code>","text":"<p>The key to expect for CData elements.</p> <p>Default is <code>_cdata</code>.</p>"},{"location":"dataformats/xml/#poskey_1","title":"<code>poskey</code>","text":"<p>The key to expect for element positions.</p> <p>Default is <code>_poskey</code>.</p>"},{"location":"dataformats/xml/#xmlnskey_1","title":"<code>xmlnskey</code>","text":"<p>The key to expect for XML namespace elements.</p> <p>Default is <code>_xmlns</code></p>"},{"location":"dataformats/xml/#xmlversion","title":"<code>xmlversion</code>","text":"<p>The xml version to use on the XML document declaration</p> <p>Default is <code>1.0</code>.</p>"},{"location":"dataformats/xml/#emptytags","title":"<code>emptytags</code>","text":"<p>Whether to output XML empty element tags e.g.: <code>&lt;element/&gt;</code> for given elements. The selected elements should be separated by whitespace</p> <p>Allowed values are <code>null</code>, <code>string</code>, and <code>object</code>.</p>"},{"location":"dataformats/xml/#exclude_1","title":"<code>exclude</code>","text":"<p>Data components to exclude when writing XML.</p> <p>Allowed values are:</p> <ul> <li><code>xml-declaration</code> an XML document declaration, also see <code>xmlversion</code></li> <li><code>attrs</code> XML attribute elements</li> </ul>"},{"location":"xtr/","title":"xtr","text":""},{"location":"xtr/#contains","title":"contains","text":""},{"location":"xtr/#array-contains","title":"Array contains","text":"<p><code>contains(arr: Array, value: Any): Boolean</code></p> <p>Returns <code>true</code> if <code>arr</code> contains the given <code>value</code>, otherwise <code>false</code>.</p> <p>Example <pre><code>xtr.contains([1, 2, 3], 1)\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/#string-contains","title":"String contains","text":"<p><code>contains(str1: String, str2: String): Boolean</code></p> <p>Returns <code>true</code> if <code>str1</code> contains <code>str2</code>, otherwise <code>false</code>.</p> <p>Example <pre><code>xtr.contains('Lorem ipsum', 'Lorem')\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/#endswith","title":"endsWith","text":"<p><code>endsWith(str1: String, str2: String): String</code></p> <p>Returns <code>true</code> if <code>str1</code> ends with <code>str2</code>, otherwise <code>false</code>.</p> <p>Example <pre><code>xtr.endsWith('Lorem ipsum', 'ipsum')\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/#entries","title":"entries","text":"<p><code>entries(obj: Object[A]): Array[Object[String|A]]</code></p> <p>Returns an <code>Array[Object[String|A]]</code> with one <code>Object[String|A]</code> for every entry in <code>obj</code>. The result has the form of <code>[{ key: String, value: A }]</code>.</p> <p>Example <pre><code>xtr.entries({ scala: '3.1.3', java: '19' })\n</code></pre> Result <pre><code>[\n  {\n    key: 'scala',\n    value: '3.1.3'\n  },\n  {\n    key: 'java',\n    value: '19'\n  }\n]\n</code></pre></p> <p></p>"},{"location":"xtr/#filter","title":"filter","text":""},{"location":"xtr/#filter-funcvalue","title":"filter func(value)","text":"<p><code>filter(arr: Array[A], predicate Func[(A) =&gt; Boolean]): Array[A]</code></p> <p>Returns a new <code>Array[A]</code> containing the elements of <code>arr</code> that satisfy the given <code>predicate</code>, which must accept an <code>A</code> value to test.</p> <p>Example <pre><code>xtr.filter([1, 2, 3, 4], function(item) item &lt; 3)\n</code></pre> Result <pre><code>[1, 2]\n</code></pre></p> <p></p>"},{"location":"xtr/#filter-funcvalue-idx","title":"filter func(value, idx)","text":"<p><code>filter(arr: Array[A], predicate Func[(A, Number) =&gt; Boolean]): Array[A]</code></p> <p>Returns a new <code>Array[A]</code> containing the elements of <code>arr</code> that satisfy the given <code>predicate</code>, which must accept an <code>A</code> value and its <code>Number</code> index to test.</p> <p>Example <pre><code>xtr.filter([1, 2, 3, 4], function(item, idx) idx &gt; 2)\n</code></pre> Result <pre><code>[4]\n</code></pre></p> <p></p>"},{"location":"xtr/#filternoteq","title":"filterNotEq","text":"<p><code>filterNotEq(arr: Array[A], value: B): Array[A]</code></p> <p>Returns a new <code>Array[A]</code> containing the elements of <code>arr</code> that are not equal to the given <code>value</code>.</p> <p>Example <pre><code>xtr.filterNotEq([1, 2, 3, 4, 3, 4], 3)\n</code></pre> Result <pre><code>[1, 2, 4, 4]\n</code></pre></p> <p></p>"},{"location":"xtr/#filternotin","title":"filterNotIn","text":"<p><code>filterNotIn(arr: Array[A], arr2: Array[B]): Array[A]</code></p> <p>Returns a new <code>Array[A]</code> containing the elements of <code>arr1</code> that are not in the given <code>arr2</code>.</p> <p>Example <pre><code>xtr.filterNotIn([1, 2, 3, 4, 3, 4], [3, 4])\n</code></pre> Result <pre><code>[1, 2]\n</code></pre></p> <p></p>"},{"location":"xtr/#filterobject","title":"filterObject","text":""},{"location":"xtr/#filterobject-funcvalue","title":"filterObject func(value)","text":"<p><code>filterObject(obj: Object[A], predicate: Func[(A) =&gt; Boolean]): Object[A]</code></p> <p>Returns a new <code>Object[A]</code> containing the entries of <code>obj</code> that satisfy the given <code>predicate</code>, which must accept an <code>A</code> value to test.</p> <p>Example <pre><code>local languages = {\n    scala: { version: '3.1.3', isJvm: true },\n    java: { version: '19', isJvm: true },\n    python: { version: '3.10.4', isJvm: false }\n};\n\nxtr.filterObject(languages, function(lang) lang.isJvm)\n</code></pre> Result <pre><code>{\n    scala: { version: '3.1.3', isJvm: true },\n    java: { version: '19', isJvm: true }\n}\n</code></pre></p> <p></p>"},{"location":"xtr/#filterobject-funcvalue-key","title":"filterObject func(value, key)","text":"<p><code>filterObject(obj: Object[A], predicate: Func[(A, String) =&gt; Boolean]): Object[A]</code></p> <p>Returns a new <code>Object[A]</code> containing the entries of <code>obj</code> that satisfy the given <code>predicate</code>, which must accept an <code>A</code> value and its corresponding <code>String</code> key to test.</p> <p>Example <pre><code>local languages = {\n    scala: { version: '3.1.3', isJvm: true },\n    java: { version: '19', isJvm: true },\n    python: { version: '3.10.4', isJvm: false }\n};\n\nxtr.filterObject(languages, function(lang, name) !lang.isJvm || name == 'scala')\n</code></pre> Result <pre><code>{\n    scala: { version: '3.1.3', isJvm: true },\n    python: { version: '3.10.4', isJvm: false }\n}\n</code></pre></p> <p></p>"},{"location":"xtr/#filterobject-funcvalue-key-idx","title":"filterObject func(value, key, idx)","text":"<p><code>filterObject(obj: Object[A], predicate: Func[(A, String, Number) =&gt; Boolean]): Object[A]</code></p> <p>Returns a new <code>Object[A]</code> containing the entries of <code>obj</code> that satisfy the given <code>predicate</code>, which must accept an <code>A</code> value and its corresponding <code>String</code> key and <code>Number</code> index to test.</p> <p>Example <pre><code>local languages = {\n    scala: { version: '3.1.3', isJvm: true },\n    java: { version: '19', isJvm: true },\n    python: { version: '3.10.4', isJvm: false }\n};\n\nxtr.filterObject(languages, function(lang, name, idx) idx == 0 || name == 'python')\n</code></pre> Result <pre><code>{\n    scala: { version: '3.1.3', isJvm: true},\n    python: { version: '3.10.4', isJvm: false}\n}\n</code></pre></p> <p></p>"},{"location":"xtr/#flatmap","title":"flatMap","text":""},{"location":"xtr/#flatmap-funcvalue","title":"flatMap func(value)","text":"<p><code>flatMap(arr: Array[A], function: Func[(A) =&gt; Array[B]]): Array[B]</code></p> <p>Returns a new <code>Array[B]</code> containing the elements of every <code>Array[B]</code> obtained by applying the given <code>function</code> to all elements in <code>arr</code>. <code>function</code> must accept an <code>A</code> value.</p> <p>Example <pre><code>xtr.flatMap([1, 3, 5], function(item) [item, item * item])\n</code></pre> Result <pre><code>[1, 1, 3, 9, 5, 25]\n</code></pre></p> <p></p>"},{"location":"xtr/#flatmap-funcvalue-idx","title":"flatMap func(value, idx)","text":"<p><code>flatMap(arr: Array[A], function: Func[(A, Number) =&gt; Array[B]]): Array[B]</code></p> <p>Returns a new <code>Array[B]</code> containing the elements of every <code>Array[B]</code> obtained by applying the given <code>function</code> to all elements in <code>arr</code>. <code>function</code> must accept an <code>A</code> value and its <code>Number</code> index.</p> <p>Example <pre><code>xtr.flatMap([1, 3, 5], function(item, idx) [item, item * idx])\n</code></pre> Result <pre><code>[1, 0, 3, 3, 5, 10]\n</code></pre></p> <p></p>"},{"location":"xtr/#flatmapobject","title":"flatMapObject","text":""},{"location":"xtr/#flatmapobject-funcvalue","title":"flatMapObject func(value)","text":"<p><code>flatMapObject(obj: Object[A], function: Func[(A) =&gt; Object[B]]): Object[B]</code></p> <p>Returns a new <code>Object[B]</code> containing the entries of every <code>Object[B]</code> obtained by applying the given <code>function</code> to all entries in <code>obj</code>. <code>function</code> must accept an <code>A</code> value.</p> <p>Example <pre><code>local candidateReqs = {\n    req1: { skillsType: 'dev', required: ['java'], preferred: ['unit-testing'] },\n    req2: { skillsType: 'ops', required: ['containers'], preferred: ['kubernetes'] }\n};\nlocal reqsWeight(req) = {\n    [req.required[0]]: 5,\n    [req.preferred[0]]: 2,\n    [if req.skillsType == 'dev' then 'github']: 4,\n    [if req.skillsType == 'ops' then 'jenkins']: 4\n};\n\nxtr.flatMapObject(candidateReqs, reqsWeight)\n</code></pre> Result <pre><code>{\n    java: 5,\n    'unit-testing': 2,\n    github: 4,\n    containers: 5,\n    kubernetes: 2,\n    jenkins: 4\n}\n</code></pre></p> <p></p>"},{"location":"xtr/#flatmapobject-funcvalue-key","title":"flatMapObject func(value, key)","text":"<p><code>flatMapObject(obj: Object[A], function: Func[(A, String) =&gt; Object[B]]): Object[B]</code></p> <p>Returns a new <code>Object[B]</code> containing the entries of every <code>Object[B]</code> obtained by applying the given <code>function</code> to all entries in <code>obj</code>. <code>function</code> must accept an <code>A</code> value and its corresponding <code>String</code> key.</p> <p>Example <pre><code>local candidateReqs = {\n    dev: { required: ['java'], preferred: ['unit-testing'] },\n    ops: { required: ['containers'], preferred: ['kubernetes'] }\n};\nlocal reqsWeight(req, type) = {\n    [req.required[0]]: 5,\n    [req.preferred[0]]: 2,\n    [if type == 'dev' then 'github']: 4,\n    [if type == 'ops' then 'jenkins']: 4\n};\n\nxtr.flatMapObject(candidateReqs, reqsWeight)\n</code></pre> Result <pre><code>{\n    java: 5,\n    'unit-testing': 2,\n    github: 4,\n    containers: 5,\n    kubernetes: 2,\n    jenkins: 4\n}\n</code></pre></p> <p></p>"},{"location":"xtr/#flatmapobject-funcvalue-key-idx","title":"flatMapObject func(value, key, idx)","text":"<p><code>flatMapObject(obj: Object[A], function: Func[(A, String, Number) =&gt; Object[B]]): Object[B]</code></p> <p>Returns a new <code>Object[B]</code> containing the entries of every <code>Object[B]</code> obtained by applying the given <code>function</code> to all entries in <code>obj</code>. <code>function</code> must accept an <code>A</code> value and its corresponding <code>String</code> key and <code>Number</code> index.</p> <p>Example <pre><code>local candidateReqs = {\n    dev: { required: ['java'], preferred: ['unit-testing'] },\n    ops: { required: ['containers'], preferred: ['kubernetes'] }\n};\nlocal reqsWeight(req, type, idx) = {\n    [req.required[0]]: 5,\n    [req.preferred[0]]: if idx == 0 then 3 else 1,\n    [if type == 'dev' then 'github']: if idx == 0 then 4 else 2,\n    [if type == 'ops' then 'jenkins']: if idx == 0 then 4 else 2\n};\n\nxtr.flatMapObject(candidateReqs, reqsWeight)\n</code></pre> Result <pre><code>{\n    java: 5,\n    'unit-testing': 3,\n    github: 4,\n    containers: 5,\n    kubernetes: 1,\n    jenkins: 2\n}\n</code></pre></p> <p></p>"},{"location":"xtr/#flatten","title":"flatten","text":"<p><code>flatten(arr: Array[Array[A]]): Array[A]</code></p> <p>Returns a new <code>Array[A]</code> containing the elements of every <code>Array[A]</code> in <code>arr</code>.</p> <p>Example <pre><code>xtr.flatten([[1, 2], [3]])\n</code></pre> Result <pre><code>[1, 2, 3]\n</code></pre></p> <p></p>"},{"location":"xtr/#foldleft","title":"foldLeft","text":"<p><code>foldLeft(arr: Array[A], initValue: Any, function: Func[(A, Any) =&gt; Any]): Any</code></p> <p>From left to right in <code>arr</code>, applies the given <code>function</code> to the first element with <code>initValue</code>, then applies it to every subsequent element with the result of the previous invocation. <code>function</code> must accept an <code>A</code> value and <code>Any</code> value, which is <code>initValue</code> for the first invocation, and the result of the previous one for all others.</p> <p>Returns the <code>Any</code> result of the final <code>function</code> invocation.</p> <p>Hint</p> <p><code>fold</code> functions usually mutate the \"accumulator\" value on each invocation, thus \"folding\" the collection into a single value.</p> <p>Example <pre><code>xtr.foldLeft([1, 2, 3], 0, function(item, acc) item + acc)\n</code></pre> Result <pre><code>6\n</code></pre></p> <p></p>"},{"location":"xtr/#foldright","title":"foldRight","text":"<p><code>foldRight(arr: Array[A], initValue: Any, Func[(A, Any) =&gt; Any]): Any</code></p> <p>From right to left in <code>arr</code>, applies the given <code>function</code> to the first element with <code>initValue</code>, then applies it to every subsequent element with the result of the previous invocation. <code>function</code> must accept an <code>A</code> value and <code>Any</code> value, which is <code>initValue</code> for the first invocation, and the result of the previous one for all others.</p> <p>Returns the <code>Any</code> result of the final <code>function</code> invocation.</p> <p>Hint</p> <p><code>fold</code> functions usually mutate the \"accumulator\" value on each invocation, thus \"folding\" the collection into a single value.</p> <p>Example <pre><code>xtr.foldRight(['Lorem', 'ipsum', 'dolor'], '', function(item, acc) acc + ' ' + item)\n</code></pre> Result <pre><code>' dolor ipsum Lorem'\n</code></pre></p> <p></p>"},{"location":"xtr/#groupby","title":"groupBy","text":""},{"location":"xtr/#array-groupby-funcvalue","title":"Array groupBy func(value)","text":"<p><code>groupBy(arr: Array[A], Func[(A) =&gt; String]): Object[Array[A]]</code></p> <p>Returns an <code>Object[Array[A]]</code> where the keys are the results of applying the given <code>function</code> to all elements in <code>arr</code>, and their corresponding values are the <code>arr</code> elements for which the <code>function</code> invocation resulted in such key. <code>function</code> must accept an <code>A</code> value.</p> <p>Example <pre><code>local languages = [\n    { name: 'scala', version: '3.1.3', isJvm: true },\n    { name: 'java', version: '19', isJvm: true },\n    { name: 'python', version: '3.10.4', isJvm: false }\n];\n\nxtr.groupBy(languages, function(lang) if lang.isJvm then 'jvmLangs' else 'others')\n</code></pre> Result <pre><code>{\n    jvmLangs: [\n        { name: 'scala', version: '3.1.3', isJvm: true },\n        { name: 'java', version: '19', isJvm: true }\n    ],\n    others: [{ name: 'python', version: '3.10.4', isJvm: false }]\n}\n</code></pre></p> <p></p>"},{"location":"xtr/#array-groupby-funcvalue-idx","title":"Array groupBy func(value, idx)","text":"<p><code>groupBy(arr: Array[A], Func[(A, Number) =&gt; String]): Object[Array[A]]</code></p> <p>Returns an <code>Object[Array[A]]</code> where the keys are the results of applying the given <code>function</code> to all elements in <code>arr</code>, and their corresponding values are the <code>arr</code> elements for which the <code>function</code> invocation resulted in such key. <code>function</code> must accept an <code>A</code> value and its <code>Number</code> index.</p> <p>Example <pre><code>local languages = [\n    { name: 'scala', version: '3.1.3', isJvm: true },\n    { name: 'java', version: '19', isJvm: true },\n    { name: 'python', version: '3.10.4', isJvm: false }\n];\nlocal langFunc(lang, idx) = if idx == 0 then 'preferred'\n    else if lang.isJvm then 'jvmLangs'\n    else 'others';\n\nxtr.groupBy(languages, langFunc)\n</code></pre> Result <pre><code>{\n    preferred: [{ name: 'scala', version: '3.1.3', isJvm: true }],\n    jvmLangs: [{ name: 'java', version: '19', isJvm: true }],\n    others: [{ name: 'python', version: '3.10.4', isJvm: false }]\n}\n</code></pre></p> <p></p>"},{"location":"xtr/#object-groupby-funcvalue","title":"Object groupBy func(value)","text":"<p><code>groupBy(obj: Object[A], Func[(A) =&gt; String]): Object[Object[A]]</code></p> <p>Returns an <code>Object[Object[A]]</code> where the keys are the results of applying the given <code>function</code> to all elements in <code>arr</code>, and their corresponding values are the <code>arr</code> elements for which the <code>function</code> invocation resulted in such key. <code>function</code> must accept an <code>A</code> value.</p> <p>Example <pre><code>local languages = {\n    scala: { version: '3.1.3', isJvm: true, project: 'scala-lang.org' },\n    java: { version: '19', isJvm: true, project: 'jdk.java.net' },\n    python: { version: '3.10.4', isJvm: false, project: 'python.org' }\n};\n\nxtr.groupBy(languages, function(lang) if lang.isJvm then 'jvmLangs' else 'others')\n</code></pre> Result <pre><code>{\n    jvmLangs: {\n        scala: { version: '3.1.3', isJvm: true, project: 'scala-lang.org' },\n        java: { version: '19', isJvm: true, project: 'jdk.java.net' }\n    },\n    others: { python: { version: '3.10.4', isJvm: false, project: 'python.org' }}\n}\n</code></pre></p> <p></p>"},{"location":"xtr/#object-groupby-funcvalue-key","title":"Object groupBy func(value, key)","text":"<p><code>groupBy(obj: Object[A], Func[(A, String) =&gt; String]): Object[Object[A]]</code></p> <p>Returns an <code>Object[Object[A]]</code> where the keys are the results of applying the given <code>function</code> to all elements in <code>arr</code>, and their corresponding values are the <code>arr</code> elements for which the <code>function</code> invocation resulted in such key.<code>function</code> must accept an <code>A</code> value and its corresponding <code>String</code> key.</p> <p>Example <pre><code>local languages = {\n    scala: { version: '3.1.3', isJvm: true, project: 'scala-lang.org' },\n    java: { version: '19', isJvm: true, project: 'jdk.java.net' },\n    python: { version: '3.10.4', isJvm: false, project: 'python.org' }\n};\nlocal langFunc(lang, name) = if name == 'scala' then 'preferred'\n    else if lang.isJvm then 'jvmLangs'\n    else 'others';\n\nxtr.groupBy(languages, langFunc)\n</code></pre> Result <pre><code>{\n    preferred: { scala: { version: '3.1.3', isJvm: true, project: 'scala-lang.org' }},\n    jvmLangs: { java: { version: '19', isJvm: true, project: 'jdk.java.net' }},\n    others: { python: { version: '3.10.4', isJvm: false, project: 'python.org' }}\n}\n</code></pre></p> <p></p>"},{"location":"xtr/#indicesof","title":"indicesOf","text":""},{"location":"xtr/#array-indicesof","title":"Array indicesOf","text":"<p><code>indicesOf(arr: Array, value: Any): Array[Number]</code></p> <p>Returns an <code>Array[Number]</code> with the indices of the elements in <code>arr</code> that equal <code>value</code>.</p> <p>Example <pre><code>xtr.indicesOf([1, 7, 3, 4, 7], 7)\n</code></pre> Result <pre><code>[1, 4]\n</code></pre></p> <p></p>"},{"location":"xtr/#string-indicesof","title":"String indicesOf","text":"<p><code>indicesOf(str1: String, str2: String): Array[Number]</code></p> <p>Returns an <code>Array[Number]</code> with the indices of the substrings in <code>str1</code> that equal <code>str2</code>.</p> <p>Example <pre><code>xtr.indicesOf('lorem ipsum dolor', 'lo')\n</code></pre> Result <pre><code>[0, 14]\n</code></pre></p> <p></p>"},{"location":"xtr/#isarray","title":"isArray","text":"<p><code>isArray(value: Any): Boolean</code></p> <p>Returns <code>true</code> if <code>value</code> is an <code>Array</code>, otherwise <code>false</code>.</p> <p>Example <pre><code>xtr.isArray([1, 2])\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/#isblank","title":"isBlank","text":"<p><code>isBlank(str: String): Boolean</code></p> <p>Returns <code>true</code> if <code>str</code> is empty or contains whitespace characters only, otherwise <code>false</code>.</p> <p>Example <pre><code>xtr.isBlank('   ')\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/#isboolean","title":"isBoolean","text":"<p><code>isBoolean(value: Any): Boolean</code></p> <p>Returns <code>true</code> if <code>value</code> is a <code>Boolean</code>, otherwise <code>false</code>.</p> <p>Example <pre><code>xtr.isBoolean(false)\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/#isdecimal","title":"isDecimal","text":"<p><code>isDecimal(num: Number): Boolean</code></p> <p>Returns <code>true</code> if <code>num</code> is a decimal, otherwise <code>false</code>.</p> <p>Example <pre><code>xtr.isDecimal(2.5)\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/#isempty","title":"isEmpty","text":""},{"location":"xtr/#array-isempty","title":"Array isEmpty","text":"<p><code>isEmpty(arr: Array): Boolean</code></p> <p>Returns <code>true</code> if <code>arr</code> is empty, otherwise <code>false</code>.</p> <p>Example <pre><code>xtr.isEmpty([])\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/#object-isempty","title":"Object isEmpty","text":"<p><code>isEmpty(obj: Object): Boolean</code></p> <p>Returns <code>true</code> if <code>obj</code> is empty, otherwise <code>false</code>.</p> <p>Example <pre><code>xtr.isEmpty({})\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/#string-isempty","title":"String isEmpty","text":"<p><code>isEmpty(str: String): Boolean</code></p> <p>Returns <code>true</code> if <code>str</code> is empty, otherwise <code>false</code>.</p> <p>Example <pre><code>xtr.isEmpty('')\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/#isfunction","title":"isFunction","text":"<p><code>isFunction(value: Any): Boolean</code></p> <p>Returns <code>true</code> if <code>value</code> is a <code>Function</code>, otherwise <code>false</code>.</p> <p>Example <pre><code>local increment(item) = item + 1;\n\nxtr.isFunction(increment)\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/#isinteger","title":"isInteger","text":"<p><code>isInteger(num: Number): Boolean</code></p> <p>Returns <code>true</code> if <code>num</code> is an integer, otherwise <code>false</code>.</p> <p>Example <pre><code>xtr.isInteger(2)\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/#isnumber","title":"isNumber","text":"<p><code>isNumber(value: Any): Boolean</code></p> <p>Returns <code>true</code> if <code>value</code> is a <code>Number</code>, otherwise <code>false</code>.</p> <p>Example <pre><code>xtr.isNumber(2)\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/#isobject","title":"isObject","text":"<p><code>isObject(value: Any): Boolean</code></p> <p>Returns <code>true</code> if <code>value</code> is an <code>Object</code>, otherwise <code>false</code>.</p> <p>Example <pre><code>xtr.isObject({})\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/#isstring","title":"isString","text":"<p><code>isString(value: Any): Boolean</code></p> <p>Returns <code>true</code> if <code>value</code> is a <code>String</code>, otherwise <code>false</code>.</p> <p>Example <pre><code>xtr.isString('Lorem')\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/#join","title":"join","text":""},{"location":"xtr/#arraynumber-join","title":"Array[Number] join","text":"<p><code>join(arr: Array[Number], separator: String): String</code></p> <p>Returns a new <code>String</code> composed of all the elements in <code>arr</code> separated by the <code>separator</code>.</p> <p>Example <pre><code>xtr.join([0, 1, 1, 2, 3, 5, 8], ', ')\n</code></pre> Result <pre><code>'0, 1, 1, 2, 3, 5, 8'\n</code></pre></p> <p></p>"},{"location":"xtr/#arraystring-join","title":"Array[String] join","text":"<p><code>join(arr: Array[String], String): String</code></p> <p>Returns a new <code>String</code> composed of all the elements in <code>arr</code> separated by the <code>separator</code>.</p> <p>Example <pre><code>xtr.join(['hello', 'world', '!'], ' ')\n</code></pre> Result <pre><code>'hello world !'\n</code></pre></p> <p></p>"},{"location":"xtr/#keys","title":"keys","text":"<p><code>keys(obj: Object): Array[String]</code></p> <p>Returns an <code>Array[String]</code> containing all the keys in <code>obj</code>.</p> <p>Example <pre><code>xtr.keys({ scala: '3.1.3', java: '19' })\n</code></pre> Result <pre><code>['scala', 'java']\n</code></pre></p> <p></p>"},{"location":"xtr/#length","title":"length","text":""},{"location":"xtr/#array-length","title":"Array length","text":"<p><code>length(arr: Array): Number</code></p> <p>Returns the size of <code>arr</code>.</p> <p>Example <pre><code>xtr.length([1, 2, 3])\n</code></pre> Result <pre><code>3\n</code></pre></p> <p></p>"},{"location":"xtr/#func-length","title":"Func length","text":"<p><code>length(func: Function): Number</code></p> <p>Returns the number of <code>func</code> parameters.</p> <p>Example <pre><code>local add(item, item2) = item + item2;\n\nxtr.length(add)\n</code></pre> Result <pre><code>2\n</code></pre></p> <p></p>"},{"location":"xtr/#object-length","title":"Object length","text":"<p><code>length(obj: Object): Number</code></p> <p>Returns the number of entries in <code>obj</code>.</p> <p>Example <pre><code>xtr.length({ key: 'value' })\n</code></pre> Result <pre><code>1\n</code></pre></p> <p></p>"},{"location":"xtr/#string-length","title":"String length","text":"<p><code>length(str: String): Number</code></p> <p>Returns the number of characters in <code>str</code>.</p> <p>Example <pre><code>xtr.length('hello, world!')\n</code></pre> Result <pre><code>13\n</code></pre></p> <p></p>"},{"location":"xtr/#map","title":"map","text":""},{"location":"xtr/#map-funcvalue","title":"map func(value)","text":"<p><code>map(arr: Array[A], function: Func[(A) =&gt; B]): Array[B]</code></p> <p>Returns a new <code>Array[B]</code> with the results of applying <code>function</code> to all elements in <code>arr</code>. <code>function</code> must accept an <code>A</code>.</p> <p>Example <pre><code>xtr.map([1, 2, 3, 4], function(item) item * item)\n</code></pre> Result <pre><code>[1, 4, 9, 16]\n</code></pre></p> <p></p>"},{"location":"xtr/#map-funcvalue-idx","title":"map func(value, idx)","text":"<p><code>map(arr: Array[A], function: Func[(A, Number) =&gt; B]): Array[B]</code></p> <p>Returns a new <code>Array[B]</code> with the results of applying <code>function</code> to all elements in <code>arr</code>. <code>function</code> must accept an <code>A</code> and its <code>Number</code> index.</p> <p>Example <pre><code>xtr.map([1, 2, 3, 4], function(item, idx) item * idx)\n</code></pre> Result <pre><code>[0, 2, 6, 12]\n</code></pre></p> <p></p>"},{"location":"xtr/#mapentries","title":"mapEntries","text":""},{"location":"xtr/#mapentries-funcvalue","title":"mapEntries func(value)","text":"<p><code>mapEntries(obj: Object[A], function: Func[(Object[A]) =&gt; B]): Array[B]</code></p> <p>Returns an <code>Array[B]</code> with the results of applying <code>function</code> to all entries in <code>obj</code>. <code>function</code> must accept an <code>A</code>.</p> <p>Example <pre><code>local languages = {\n    scala: { version: '3.1.3', isJvm: true, project: 'scala-lang.org' },\n    java: { version: '19', isJvm: true, project: 'jdk.java.net' },\n    python: { version: '3.10.4', isJvm: false, project: 'python.org' }\n};\n\nxtr.mapEntries(languages, function(lang) lang.project)\n</code></pre> Result <pre><code>['scala-lang.org', 'jdk.java.net', 'python.org']\n</code></pre></p> <p></p>"},{"location":"xtr/#mapentries-funcvalue-key","title":"mapEntries func(value, key)","text":"<p><code>mapEntries(obj: Object[A], function: Func[(Object[A], String) =&gt; B]): Array[B]</code></p> <p>Returns an <code>Array[B]</code> with the results of applying <code>function</code> to all entries in <code>obj</code>. <code>function</code> must accept an <code>A</code> and its corresponding <code>String</code> key.</p> <p>Example <pre><code>local languages = {\n    scala: { version: '3.1.3', isJvm: true, project: 'scala-lang.org' },\n    java: { version: '19', isJvm: true, project: 'jdk.java.net' }\n};\n\nxtr.mapEntries(languages, function(lang, name) {\n    name: name,\n    version: lang.version\n})\n</code></pre> Result <pre><code>[\n    { name: 'scala', version: '3.1.3' },\n    { name: 'java', version: '19' }\n]\n</code></pre></p> <p></p>"},{"location":"xtr/#mapentries-funcvalue-key-idx","title":"mapEntries func(value, key, idx)","text":"<p><code>mapEntries(obj: Object[A], function: Func[(Object[A], String, Number) =&gt; B]): Array[B]</code></p> <p>Returns an <code>Array[B]</code> with the results of applying <code>function</code> to all entries in <code>obj</code>. <code>function</code> must accept an <code>A</code> and its corresponding <code>String</code> key and <code>Number</code> index.</p> <p>Example <pre><code>local languages = {\n    scala: { version: '3.1.3', isJvm: true, project: 'scala-lang.org' },\n    java: { version: '19', isJvm: true, project: 'jdk.java.net' }\n};\nlocal langFunc(lang, name, idx) = {\n    name: name,\n    [if idx == 0 then 'preferred']: true\n};\n\nxtr.mapEntries(languages, langFunc)\n</code></pre> Result <pre><code>[{ name: 'scala', preferred: true }, { name: 'java' }]\n</code></pre></p> <p></p>"},{"location":"xtr/#mapobject","title":"mapObject","text":""},{"location":"xtr/#mapobject-funcvalue","title":"mapObject func(value)","text":"<p><code>mapObject(obj: Object[A], function: Func[(A) =&gt; Object[B]]): Object[B]</code></p> <p>Returns a new Object[B] containing the entry of every Object[B] obtained by applying the given <code>function</code> to all entries in obj. <code>function</code> must accept an <code>A</code> value.</p> <p></p>"},{"location":"xtr/#mapobject-funcvalue-key","title":"mapObject func(value, key)","text":"<p><code>mapObject(obj: Object[A], function: Func[(A, String) =&gt; Object[B]]): Object[B]</code></p> <p>Returns a new Object[B] containing the entry of every Object[B] obtained by applying the given <code>function</code> to all entries in obj. <code>function</code> must accept an <code>A</code> value and its corresponding <code>String</code> key.</p> <p></p>"},{"location":"xtr/#mapobject-funcvalue-key-idx","title":"mapObject func(value, key, idx)","text":"<p><code>mapObject(obj: Object[A], function: Func[(A, String, Number) =&gt; Object[B]]): Object[B]</code></p> <p>Returns a new Object[B] containing the entry of every Object[B] obtained by applying the given <code>function</code> to all entries in obj. <code>function</code> must accept an <code>A</code> value and its corresponding <code>String</code> key and <code>Number</code> index.</p> <p></p>"},{"location":"xtr/#max","title":"max","text":""},{"location":"xtr/#arrayboolean-max","title":"Array[Boolean] max","text":"<p><code>max(arr: Array[Boolean]): Boolean</code></p> <p>Returns the max <code>Boolean</code> in <code>arr</code>, with <code>true</code> being \"bigger\" than <code>false</code>.</p> <p>Example <pre><code>xtr.max([false, false, true])\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/#arraynumber-max","title":"Array[Number] max","text":"<p><code>max(arr: Array[Number]): Number</code></p> <p>Returns the max <code>Number</code> in <code>arr</code>.</p> <p>Example <pre><code>xtr.max([0, 8, 2, 100])\n</code></pre> Result <pre><code>100\n</code></pre></p> <p></p>"},{"location":"xtr/#arraystring-max","title":"Array[String] max","text":"<p><code>max(arr: Array[String]): String</code></p> <p>Returns the max <code>String</code> in <code>arr</code>.</p> <p>Example <pre><code>xtr.max(['Lorem', 'zzz', 'ipsum', 'dolor'])\n</code></pre> Result <pre><code>'zzz'\n</code></pre></p> <p></p>"},{"location":"xtr/#maxby","title":"maxBy","text":""},{"location":"xtr/#maxby-func_-boolean","title":"maxBy func(_) =&gt; Boolean","text":"<p><code>maxBy(arr: Array[A], function: Func[(A) =&gt; Boolean]): Array[A]</code></p> <p>Returns the max <code>A</code> by comparing the values returned by <code>function</code>, which must accept an <code>A</code>.</p> <p>Example <pre><code>local languages = [\n    { name: 'java', version: '19', isPreferred: false },\n    { name: 'python', version: '3.1.14', isPreferred: false }\n    { name: 'scala', version: '3.1.3', isPreferred: true },\n];\n\nxtr.maxBy(languages, function(lang) lang.isPreferred)\n</code></pre> Result <pre><code>{ name: 'scala', version: '3.1.3', isPreferred: true }\n</code></pre></p> <p></p>"},{"location":"xtr/#maxby-func_-number","title":"maxBy func(_) =&gt; Number","text":"<p><code>maxBy(arr: Array[A], function: Func[(A) =&gt; Number]): Array[A]</code></p> <p>Returns the max <code>A</code> by comparing the values returned by <code>function</code>, which must accept an <code>A</code>.</p> <p>Example <pre><code>local languages = [\n    { name: 'java', version: '19', weight: 2 },\n    { name: 'python', version: '3.1.14', weight: 2 }\n    { name: 'scala', version: '3.1.3', weight: 4 },\n];\n\nxtr.maxBy(languages, function(lang) lang.weight)\n</code></pre> Result <pre><code>{ name: 'scala', version: '3.1.3', weight: 4 }\n</code></pre></p> <p></p>"},{"location":"xtr/#maxby-func_-string","title":"maxBy func(_) =&gt; String","text":"<p><code>maxBy(arr: Array[A], function: Func[(A) =&gt; String]): Array[A]</code></p> <p>Returns the max <code>A</code> by comparing the values returned by <code>function</code>, which must accept an <code>A</code>.</p> <p>Example <pre><code>local languages = [\n    { name: 'java', version: '19', score: 'B' },\n    { name: 'python', version: '3.1.14', score: 'B' },\n    { name: 'scala', version: '3.1.3', score: 'S' }\n];\n\nxtr.maxBy(languages, function(lang) lang.score)\n</code></pre> Result <pre><code>{ name: 'scala', version: '3.1.3', score: 'S' }\n</code></pre></p> <p></p>"},{"location":"xtr/#min","title":"min","text":""},{"location":"xtr/#arrayboolean-min","title":"Array[Boolean] min","text":"<p><code>min(arr: Array[Boolean]): Boolean</code></p> <p>Returns the min <code>Boolean</code> in <code>arr</code>, with <code>false</code> being \"smaller\" than <code>true</code>.</p> <p>Example <pre><code>xtr.min([false, false, true])\n</code></pre> Result <pre><code>false\n</code></pre></p> <p></p>"},{"location":"xtr/#arraynumber-min","title":"Array[Number] min","text":"<p><code>min(arr: Array[Number]): Number</code></p> <p>Returns the min <code>Number</code> in <code>arr</code>.</p> <p>Example <pre><code>xtr.min([0, 8, 2, 100])\n</code></pre> Result <pre><code>0\n</code></pre></p> <p></p>"},{"location":"xtr/#arraystring-min","title":"Array[String] min","text":"<p><code>min(arr: Array[String]): String</code></p> <p>Returns the min <code>String</code> in <code>arr</code>.</p> <p>Example <pre><code>xtr.min(['Lorem', 'AAA', 'ipsum', 'dolor'])\n</code></pre> Result <pre><code>'AAA'\n</code></pre></p> <p></p>"},{"location":"xtr/#minby","title":"minBy","text":""},{"location":"xtr/#minby-func_-boolean","title":"minBy func(_) =&gt; Boolean","text":"<p><code>minBy(arr: Array[A], comparator: Func[(A) =&gt; Boolean]): Array[A]</code></p> <p>Returns the min <code>A</code> by comparing the values returned by <code>function</code>, which must accept an <code>A</code>.</p> <p>Example <pre><code>local languages = [\n    { name: 'java', version: '19', isPreferred: false },\n    { name: 'python', version: '3.1.14', isPreferred: false },\n    { name: 'scala', version: '3.1.3', isPreferred: true }\n];\n\nxtr.minBy(languages, function(lang) lang.isPreferred)\n</code></pre> Result <pre><code>{ name: 'java', version: '19', isPreferred: false }\n</code></pre></p> <p></p>"},{"location":"xtr/#minby-func_-number","title":"minBy func(_) =&gt; Number","text":"<p><code>minBy(arr: Array[A], comparator: Func[(A) =&gt; Number]): Array[A]</code></p> <p>Returns the min <code>A</code> by comparing the values returned by <code>function</code>, which must accept an <code>A</code>.</p> <p>Example <pre><code>local languages = [\n    { name: 'java', version: '19', weight: 2 },\n    { name: 'python', version: '3.1.14', weight: 2 },\n    { name: 'scala', version: '3.1.3', weight: 4 }\n];\n\nxtr.minBy(languages, function(lang) lang.weight)\n</code></pre> Result <pre><code>{ name: 'java', version: '19', weight: 2 }\n</code></pre></p> <p></p>"},{"location":"xtr/#minby-func_-string","title":"minBy func(_) =&gt; String","text":"<p><code>minBy(arr: Array[A], comparator: Func[(A) =&gt; String]): Array[A]</code></p> <p>Returns the min <code>A</code> by comparing the values returned by <code>function</code>, which must accept an <code>A</code>.</p> <p>Example <pre><code>local languages = [\n    { name: 'java', version: '19', score: 'B' },\n    { name: 'python', version: '3.1.14', score: 'B' },\n    { name: 'scala', version: '3.1.3', score: 'S' }\n];\n\nxtr.minBy(languages, function(lang) lang.score)\n</code></pre> Result <pre><code>{ name: 'java', version: '19', score: 'B' }\n</code></pre></p> <p></p>"},{"location":"xtr/#parsenum","title":"parseNum","text":"<p><code>parseNum(str: String): Number</code></p> <p>Returns the <code>Number</code> representation of the given <code>str</code>.</p> <p>Example <pre><code>parseNum('123.45')\n</code></pre> Result <pre><code>123.45\n</code></pre></p> <p></p>"},{"location":"xtr/#sortby","title":"sortBy","text":""},{"location":"xtr/#sortby-func_-boolean","title":"sortBy func(_) =&gt; Boolean","text":"<p><code>sortBy(arr: Array[A], Func[(A) =&gt; Boolean]): Array[A]</code></p> <p>Returns a new <code>Array[A]</code> with the conents of <code>arr</code> sorted by comparing the values returned by <code>function</code>, which must accept and <code>A</code>.</p> <p>Example <pre><code>local languages = [\n    { name: 'java', version: '19', isPreferred: false },\n    { name: 'scala', version: '3.1.3', isPreferred: true },\n    { name: 'python', version: '3.1.14', isPreferred: false }\n];\n\nxtr.minBy(languages, function(lang) lang.isPreferred)\n</code></pre> Result <pre><code>[\n    { name: 'java', version: '19', isPreferred: false },\n    { name: 'python', version: '3.1.14', isPreferred: false },\n    { name: 'scala', version: '3.1.3', isPreferred: true }\n]\n</code></pre></p> <p></p>"},{"location":"xtr/#sortby-func_-number","title":"sortBy func(_) =&gt; Number","text":"<p><code>sortBy(arr: Array[A], Func[(A) =&gt; Number]): Array[A]</code></p> <p>Returns a new <code>Array[A]</code> with the conents of <code>arr</code> sorted by comparing the values returned by <code>function</code>, which must accept and <code>A</code>.</p> <p>Example <pre><code>local languages = [\n    { name: 'java', version: '19', weight: 3 },\n    { name: 'scala', version: '3.1.3', weight: 4 },\n    { name: 'python', version: '3.1.14', weight: 2 }\n];\n\nxtr.sortBy(languages, function(lang) lang.weight)\n</code></pre> Result <pre><code>[\n    { name: 'python', version: '3.1.14', weight: 2 },\n    { name: 'java', version: '19', weight: 3 },\n    { name: 'scala', version: '3.1.3', weight: 4 }\n]\n</code></pre></p> <p></p>"},{"location":"xtr/#sortby-func_-string","title":"sortBy func(_) =&gt; String","text":"<p><code>sortBy(arr: Array[A], Func[(A) =&gt; String]): Array[A]</code></p> <p>Returns a new <code>Array[A]</code> with the conents of <code>arr</code> sorted by comparing the values returned by <code>function</code>, which must accept and <code>A</code>.</p> <p>Example <pre><code>local languages = [\n    { name: 'java', version: '19', score: 'B' },\n    { name: 'scala', version: '3.1.3', score: 'S' },\n    { name: 'python', version: '3.1.14', score: 'B' }\n];\n\nxtr.sortBy(languages, function(lang) lang.score)\n</code></pre> Result <pre><code>[\n    { name: 'java', version: '19', score: 'B' },\n    { name: 'python', version: '3.1.14', score: 'B' },\n    { name: 'scala', version: '3.1.3', score: 'S' }\n]\n</code></pre></p> <p></p>"},{"location":"xtr/#range","title":"range","text":"<p><code>range(first: Number, last: Number): Array[Number]</code></p> <p>Returns an <code>Array[Number]</code> containing numbers from <code>first</code> to <code>last</code>.</p> <p>Example <pre><code>xtr.range(1, 5)\n</code></pre> Result <pre><code>[1, 2, 3, 4, 5]\n</code></pre></p> <p></p>"},{"location":"xtr/#read","title":"read","text":""},{"location":"xtr/#read-mediatype","title":"read mediaType","text":"<p><code>read(data: String, mediaType: String): Any</code></p> <p>Parses the <code>data</code> as the given <code>mediaType</code> using the data format plugins available to the <code>Transformer</code>.</p> <p>Example <pre><code>xtr.read('&lt;hello&gt;world!&lt;/hello&gt;', 'application/xml')\n</code></pre> Result <pre><code>{\n  hello: { '$': 'world!' }\n}\n</code></pre></p> <p></p>"},{"location":"xtr/#read-mediatype-params","title":"read mediaType, params","text":"<p><code>read(data: String, mediaType: String, params: Object): Any</code></p> <p>Parses the <code>data</code> as the given <code>mediaType</code> and <code>params</code> options using the data format plugins available to the <code>Transformer</code>.</p> <p>Example <pre><code>xtr.read('&lt;hello&gt;world!&lt;/hello&gt;', 'application/xml', { textkey: '_txt' })\n</code></pre> Result <pre><code>{\n  hello: { _txt: 'world!' }\n}\n</code></pre></p> <p></p>"},{"location":"xtr/#readurl","title":"readUrl","text":""},{"location":"xtr/#readurl-mediatype","title":"readUrl mediaType","text":"<p><code>readUrl(url: String, mediaType: String): Any</code></p> <p>Retrieves the data at <code>url</code> and parses it as the given <code>mediaType</code>. Supported schemes/protocols are <code>http</code>, <code>https</code>, <code>classpath</code>, and <code>file</code>.</p> <p>Asumming <code>example.com</code> returns <code>&lt;hello&gt;world!&lt;/hello&gt;</code>:</p> <p>Example <pre><code>xtr.readUrl('example.com/data', 'application/xml')\n</code></pre> Result <pre><code>{\n  hello: { '$': 'world!' }\n}\n</code></pre></p> <p></p>"},{"location":"xtr/#readurl-mediatype-params","title":"readUrl mediaType, params","text":"<p><code>readUrl(url: String, mediaType: String, params: Object): Any</code></p> <p>Retrieves the data at <code>url</code> and parses it as the given <code>mediaType</code> with <code>params</code> options. Supported schemes/protocols are <code>http</code>, <code>https</code>, <code>classpath</code>, and <code>file</code>.</p> <p>Asumming <code>example.com</code> returns <code>&lt;hello&gt;world!&lt;/hello&gt;</code>:</p> <p>Example <pre><code>xtr.readUrl('example.com', 'application/xml', { textkey: '_txt' })\n</code></pre> Result <pre><code>{\n  hello: { _txt: 'world!' }\n}\n</code></pre></p> <p></p>"},{"location":"xtr/#rmkey","title":"rmKey","text":"<p><code>rmKey(obj: Object[A], key: String): Object[A]</code></p> <p>Returns a new <code>Object[A]</code> containing the entries of <code>obj</code> minus the entry for the given <code>key</code>.</p> <p>Example <pre><code>xtr.rmKey({ scala: '3.1.3', java: '19' }, 'java')\n</code></pre> Result <pre><code>{ scala: '3.1.3' }\n</code></pre></p> <p></p>"},{"location":"xtr/#rmkeyin","title":"rmKeyIn","text":"<p><code>rmKeyIn(obj: Object[A], arr: Array[String]): Object[A]</code></p> <p>Returns a new <code>Object[A]</code> containing the entries of <code>obj</code> minus the entries whose key is in the given <code>arr</code>.</p> <p>Example <pre><code>xtr.rmKeyIn({ scala: '3.1.3', java: '19' }, ['java', 'scala'])\n</code></pre> Result <pre><code>{}\n</code></pre></p> <p></p>"},{"location":"xtr/#replace","title":"replace","text":"<p><code>replace(str1: String, str2: String, str3: String): String</code></p> <p>Returns a new <code>String</code> with the contents of <code>str1</code>, with occurrences of <code>str2</code> replaced by <code>str3</code>.</p> <p>Example <pre><code>xtr.replace('hello, world!', 'world', 'everyone')\n</code></pre> Result <pre><code>'hello, everyone!'\n</code></pre></p> <p></p>"},{"location":"xtr/#reverse","title":"reverse","text":""},{"location":"xtr/#array-reverse","title":"Array reverse","text":"<p><code>reverse(arr: Array): Array</code></p> <p>Returns a new <code>Array</code> with the elements of <code>arr</code> in reversed order.</p> <p>Example <pre><code>xtr.reverse([1, 2, 3])\n</code></pre> Result <pre><code>[3, 2, 1]\n</code></pre></p> <p></p>"},{"location":"xtr/#object-reverse","title":"Object reverse","text":"<p><code>reverse(obj: Object): Object</code></p> <p>Returns a new <code>Object</code> with the entries of <code>obj</code> in reversed order.</p> <p>Example <pre><code>xtr.reverse({ key1: 'value1', key2: 'value2' })\n</code></pre> Result <pre><code>{ key2: 'value2', key1: 'value1' }\n</code></pre></p> <p></p>"},{"location":"xtr/#string-reverse","title":"String reverse","text":"<p><code>reverse(str: String): String</code></p> <p>Returns a new <code>String</code> with the characters of <code>str</code> in reversed order.</p> <p>Example <pre><code>xtr.reverse('rolod muspi meroL')\n</code></pre> Result <pre><code>'Lorem ipsum dolor'\n</code></pre></p> <p></p>"},{"location":"xtr/#split","title":"split","text":"<p><code>split(str1: String, str2: String): Array[String]</code></p> <p>Returns an <code>Array[String]</code> containing the chunks of <code>str1</code> split by the contents of <code>str2</code>.</p> <p>Example <pre><code>xtr.split('hello, world!', 'o')\n</code></pre> Result <pre><code>['hell', ', w', 'rld!']\n</code></pre></p> <p></p>"},{"location":"xtr/#startswith","title":"startsWith","text":"<p><code>startsWith(str1: String, str2: String): Boolean</code></p> <p>Returns <code>true</code> if <code>str1</code> starts with <code>str2</code>.</p> <p>Example <pre><code>xtr.startsWith('hello, world!', 'hello')\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/#tolowercase","title":"toLowerCase","text":"<p><code>toLowerCase(str: String): String</code></p> <p>Returns the lowercase representation of <code>str</code>.</p> <p>Example <pre><code>xtr.toLowerCase('Hello World!')\n</code></pre> Result <pre><code>'hello world!'\n</code></pre></p> <p></p>"},{"location":"xtr/#tostring","title":"toString","text":"<p><code>toString(value: String|Number|Boolean|Null): String</code></p> <p>Returns the <code>String</code> representation of <code>value</code>.</p> <p>Example <pre><code>{\n    bool: xtr.toString(true),\n    num: xtr.toString(365),\n    nil: xtr.toString(null)\n}\n</code></pre> Result <pre><code>{\n    bool: 'true',\n    num: '365',\n    nil: 'null'\n}\n</code></pre></p> <p></p>"},{"location":"xtr/#touppercase","title":"toUpperCase","text":"<p><code>toUpperCase(String): String</code></p> <p>Returns the uppercase representation of <code>str</code>.</p> <p>Example <pre><code>xtr.toUpperCase('Hello World!')\n</code></pre> Result <pre><code>'HELLO WORLD!'\n</code></pre></p> <p></p>"},{"location":"xtr/#trim","title":"trim","text":"<p><code>trim(str: String): String</code></p> <p>Returns a new <code>String</code> with the contents of <code>str</code> removed of leading and trailing whitespaces.</p> <p>Example <pre><code>xtr.trim('  hello, world!   ')\n</code></pre> Result <pre><code>'hello, world!'\n</code></pre></p> <p></p>"},{"location":"xtr/#type","title":"type","text":"<p><code>type(value: Any): String</code></p> <p>Returns the <code>String</code> name of the type of <code>value</code>.</p> <p>Example <pre><code>local func(it) = it;\n\n{\n    bool: xtr.type(true),\n    num: xtr.type(365),\n    nil: xtr.type(null),\n    arr: xtr.type([]),\n    obj: xtr.type({}),\n    func: xtr.type(func)\n}\n</code></pre> Result <pre><code>{\n    bool: 'boolean',\n    num: 'number',\n    nil: 'null',\n    arr: 'array',\n    obj: 'object',\n    func: 'function'\n}\n</code></pre></p> <p></p>"},{"location":"xtr/#uuid","title":"uuid","text":"<p><code>uuid(): String</code></p> <p>Generates a new random UUID v4 <code>String</code>.</p> <p>Example <pre><code>xtr.uuid()\n</code></pre> Result <pre><code>'8eae62af-d2dc-4759-8316-ce6eeca0b61c'\n</code></pre></p> <p></p>"},{"location":"xtr/#values","title":"values","text":"<p><code>values(obj: Object[A]): Array[A]</code></p> <p>Returns an <code>Array[String]</code> containing all the values in <code>obj</code>.</p> <p>Example <pre><code>xtr.values({ scala: '3.1.3', java: '19' })\n</code></pre> Result <pre><code>['3.1.3', '19']\n</code></pre></p> <p></p>"},{"location":"xtr/#write","title":"write","text":""},{"location":"xtr/#write-mediatype","title":"write mediaType","text":"<p><code>write(data: Any, mediaType: String): String</code></p> <p>Writes the <code>data</code> in the given <code>mediaType</code> format using the data format plugins available to the <code>Transformer</code>.</p> <p>Example <pre><code>xtr.write({ hello: 'world', arr: [], nil: null }, 'application/json')\n</code></pre> Result <pre><code>'{\"hello\":\"world\",\"arr\":[],\"nil\":null}'\n</code></pre></p> <p></p>"},{"location":"xtr/#write-mediatype-params","title":"write mediaType, params","text":"<p><code>write(data: Any, mediaType: String, params: Object[): String</code></p> <p>Writes the <code>data</code> in the given <code>mediaType</code> format and <code>params</code> options using the data format plugins available to the <code>Transformer</code>.</p> <p>Example <pre><code>xtr.write({ hello: 'world', arr: [] }, 'application/json', { indent: true })\n</code></pre> Result <pre><code>'{\\n    \"hello\": \"world\",\\n    \"arr\": [\\n        \\n    ]\\n}'\n</code></pre></p>"},{"location":"xtr/arrays/","title":"xtr.arrays","text":""},{"location":"xtr/arrays/#all","title":"all","text":"<p><code>all(arr: Array[A], predicate: Func[(A) =&gt; Boolean]): Boolean</code></p> <p>Returns <code>true</code> if all elements in <code>arr</code> satisfy the given <code>predicate</code>, otherwise <code>false</code>. <code>predicate</code> must accept an <code>A</code>.</p> <p>Example <pre><code>xtr.arrays.all([1, 2, 3], function(item) item &gt; 0)\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/arrays/#any","title":"any","text":"<p><code>any(arr: Array[A], function: Func[(A) =&gt; Boolean]): Boolean</code></p> <p>Returns <code>true</code> if any element in <code>arr</code> satisfies the given <code>predicate</code>, otherwise <code>false</code>. <code>predicate</code> must accept an <code>A</code>.</p> <p>Example <pre><code>xtr.arrays.any([1, 2, 3], function(item) item &gt; 1)\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/arrays/#break","title":"break","text":"<p><code>break(arr: Array[A], predicate: Func[(A) =&gt; Boolean]): Object[Array[A]]</code></p> <p>Returns an <code>Object</code> with two entries:</p> <ul> <li><code>left</code> key with an <code>Array[A]</code> containing the elements of <code>arr</code> before the first element to satisfy the given <code>predicate</code>.</li> <li><code>right</code> key with an <code>Array[A]</code> containing the remaining elements of <code>arr</code>.</li> </ul> <p>Example <pre><code>xtr.arrays.break([1, 2, 3, 4, 5], function(item) item % 2 == 0)\n</code></pre> Result <pre><code>{ left: [1], right: [2, 3, 4, 5] }\n</code></pre></p> <p></p>"},{"location":"xtr/arrays/#chunksof","title":"chunksOf","text":"<p><code>chunksOf(arr: Array[A], size: Number): Array[Array[A]]</code></p> <p>Returns a new <code>Array</code> of <code>Array[A]</code>, with every element containing the next <code>size</code> elements in <code>arr</code>.</p> <p>Example <pre><code>xtr.arrays.chunksOf([1, 2, 3, 4, 5], 2)\n</code></pre> Result <pre><code>[[1, 2], [3, 4], [5]]\n</code></pre></p> <p></p>"},{"location":"xtr/arrays/#countby","title":"countBy","text":"<p><code>countBy(arr: Array[A], predicate: Func[(A) =&gt; Boolean]): Number</code></p> <p>Returns a <code>Number</code> count of all the elements in <code>array</code> that satisfy the given <code>predicate</code>, which must accept and <code>A</code>.</p> <p>Example <pre><code>xtr.arrays.countBy([1, 2, 3], function(item) item &gt; 2)\n</code></pre> Result <pre><code>1\n</code></pre></p> <p></p>"},{"location":"xtr/arrays/#distinctby","title":"distinctBy","text":""},{"location":"xtr/arrays/#distinctby-funcvalue","title":"distinctBy func(value)","text":"<p><code>distinctBy(arr: Array[A], identity: Func[(A) =&gt; B]): Array[A]</code></p> <p>Returns a new <code>Array</code> with the distinct elements in <code>arr</code> using the given <code>identity</code> function for comparison. <code>identity</code> must accept an <code>A</code>.</p> <p>Example <pre><code>xtr.arrays.distinctBy([1, 2, 3, 4, 5, 6], function(item) item % 3)\n</code></pre> Result <pre><code>[1, 2, 3]\n</code></pre></p> <p>The modulo operation on the elements yields <code>[1, 2, 0, 1, 2, 0]</code> meaning <code>1</code> and <code>4</code> share the same identity, therefore <code>1</code> is kept and <code>4</code> discarded. Same is true for <code>2</code> and <code>3</code> with <code>5</code> and <code>6</code>, respectively.</p> <p></p>"},{"location":"xtr/arrays/#distinctby-funcvalue-idx","title":"distinctBy func(value, idx)","text":"<p><code>distinctBy(arr: Array[A], identity: Func[(A, Number) =&gt; B]): Array[A]</code></p> <p>Returns a new <code>Array</code> with the distinct elements in <code>arr</code> using the given <code>identity</code> function for comparison. <code>identity</code> must accept an <code>A</code>.</p> <p>Example <pre><code>xtr.arrays.distinctBy([1, 2, 3, 4, 5, 6], function(item, idx) item % (3 * idx))\n</code></pre> Result <pre><code>[1, 2, 3, 4, 5, 6]\n</code></pre></p> <p>The modulo operation on the elements yields <code>[0, 2, 3, 4, 5, 6]</code> where all are distinct, so all elements are kept.</p> <p></p>"},{"location":"xtr/arrays/#drop","title":"drop","text":"<p><code>drop(arr: Array[A], n: Number): Array[A]</code></p> <p>Returns a new <code>Array</code> with the elements in <code>arr</code> but dropping the first <code>n</code> elements.</p> <p>Example <pre><code>xtr.arrays.drop([1, 2, 3, 4, 5], 3)\n</code></pre> Result <pre><code>[4, 5]\n</code></pre></p> <p></p>"},{"location":"xtr/arrays/#dropwhile","title":"dropWhile","text":"<p><code>dropWhile(arr: Array[A], predicate: Func[(A) =&gt; Boolean]): Array[A]</code></p> <p>Returns a new <code>Array</code> with the elements in <code>arr</code>, but dropping the first elements while they satisfy the given <code>predicate</code>, which must accept an <code>A</code>.</p> <p>Example <pre><code>xtr.arrays.dropWhile([1, 2, 3, 4, 5], function(item) item * 3 &lt; 10)\n</code></pre> Result <pre><code>[4, 5]\n</code></pre></p> <p></p>"},{"location":"xtr/arrays/#duplicatesby","title":"duplicatesBy","text":"<p><code>duplicatesBy(arr: Array[A]): Array[A]</code></p> <p>Returns a new <code>Array</code> with the element in <code>arr</code> that are duplicated.</p> <p>Example <pre><code>xtr.arrays.duplicatesBy([1, 2, 3, 1, 2])\n</code></pre> Result <pre><code>[1, 2]\n</code></pre></p> <p></p>"},{"location":"xtr/arrays/#find","title":"find","text":""},{"location":"xtr/arrays/#find-funcvalue","title":"find func(value)","text":"<p><code>find(arr: Array[A], predicate: Func[(A) =&gt; Boolean]): [A]</code></p> <p>Returns a single element <code>Array</code> with the first <code>A</code> that satisfies the given <code>predicate</code>, which must accept an <code>A</code>.</p> <p>Example <pre><code>xtr.arrays.find([1, 2, 3, 4, 5], function(item) item * 3 &gt; 10)\n</code></pre> Result <pre><code>[4]\n</code></pre></p> <p></p>"},{"location":"xtr/arrays/#find-funcvalue-idx","title":"find func(value, idx)","text":"<p><code>find(arr: Array[A], predicate: Func[(A, Number) =&gt; Boolean]): [A]</code></p> <p>Returns a single element <code>Array</code> with the first <code>A</code> that satisfies the given <code>predicate</code>, which must accept an <code>A</code> and its <code>Number</code> index.</p> <p>Example <pre><code>xtr.arrays.find([1, 2, 3, 4, 5], function(item, idx) item * (3 + idx) &gt; 10)\n</code></pre> Result <pre><code>[3]\n</code></pre></p> <p></p>"},{"location":"xtr/arrays/#flat","title":"flat","text":"<p><code>flat(arr: Array[Array[A]]): Array[Any]</code></p> <p>Returns a new single level <code>Array</code> with the contents of all <code>Array</code> in <code>arr</code>, recursively flattening each <code>Array</code> element found.</p> <p>Example <pre><code>xtr.arrays.flat([[1, 2], '3', [4, {}, [5, 6]]])\n</code></pre> Result <pre><code>[1, 2, '3', 4, {}, 5, 6]\n</code></pre></p> <p></p>"},{"location":"xtr/arrays/#indexwhere","title":"indexWhere","text":"<p><code>indexWhere(arr: Array[A], predicate: Func[(A) =&gt; Boolean]): Number</code></p> <p>Returns the <code>Number</code> index of the first element that satisfies the given <code>predicate</code>, otherwise <code>-1</code>. <code>predicate</code> which must accept an <code>A</code>.</p> <p>Example <pre><code>xtr.arrays.indexWhere([1, 2, 3, 4, 5], function(item) item * 3 &lt; 10)\n</code></pre> Result <pre><code>0\n</code></pre></p> <p></p>"},{"location":"xtr/arrays/#indiceswhere","title":"indicesWhere","text":"<p><code>indicesWhere(arr: Array[A], predicate: Func[(A) =&gt; Boolean]): Array[Number]</code></p> <p>Returns an <code>Array[Number]</code> with the indices of elements that satisfy the given <code>predicate</code>, which must accept an <code>A</code>.</p> <p>Example <pre><code>xtr.arrays.indicesWhere([1, 2, 3, 4, 5], function(item) item * 3 &lt; 10)\n</code></pre> Result <pre><code>[0, 1, 2]\n</code></pre></p> <p></p>"},{"location":"xtr/arrays/#lastindexwhere","title":"lastIndexWhere","text":"<p><code>lastIndexWhere(arr: Array[A], predicate: Func[(A) =&gt; Boolean]): Number</code></p> <p>Returns the <code>Number</code> index of the last element in <code>arr</code> that satisfies the given <code>predicate</code>, otherwise <code>-1</code>. <code>predicate</code> which must accept an <code>A</code>.</p> <p>Example <pre><code>xtr.arrays.lastIndexWhere([1, 2, 3, 4, 5], function(item) item * 3 &lt; 10)\n</code></pre> Result <pre><code>2\n</code></pre></p> <p></p>"},{"location":"xtr/arrays/#occurrencesby","title":"occurrencesBy","text":"<p><code>occurrencesBy(arr: Array[A], identity: Func[(A) =&gt; String]): Object[Number]</code></p> <p>Returns an <code>Object</code> with an entry for each unique identity of elements in <code>arr</code>. The value of each entry is the <code>Number</code> of elements in <code>arr</code> that produced such identity, using <code>identity</code>. <code>identity</code> must take an <code>A</code>.</p> <p>Example <pre><code>xtr.arrays.occurrencesBy([1, 2, 3, 4, 5], function(item) if (item) &lt; 4 then 'under4' else 'over4')\n</code></pre> Result <pre><code>{ 'under4': 3, 'over4': 2 }\n</code></pre></p> <p></p>"},{"location":"xtr/arrays/#partition","title":"partition","text":"<p><code>partition(arr: Array[A], predicate: Func[(A) =&gt; Boolean]): Object[A]</code></p> <p>Returns an <code>Object</code> with two entries:</p> <ul> <li><code>pass</code> key with an <code>Array[A]</code> of the subset of elements in <code>arr</code> that satisfy the given <code>predicate</code>, which must take an <code>A</code>.</li> <li><code>fail</code> key with an <code>Array[A]</code> of the subset of elements in <code>arr</code> that fail the given <code>predicate</code>, which must take an <code>A</code>.</li> </ul> <p>Example <pre><code>xtr.arrays.partition([1, 2, 3, 4, 5], function(item) item &lt; 4)\n</code></pre> Result <pre><code>{ pass: [1, 2, 3], fail: [4, 5] }\n</code></pre></p> <p></p>"},{"location":"xtr/arrays/#splitat","title":"splitAt","text":"<p><code>splitAt(arr: Array[A], n: Number): Object[A]</code></p> <p>Returns an <code>Object[A]</code> with two entries:</p> <ul> <li><code>left</code> key with an <code>Array[A]</code> containing the elements of <code>arr</code> before the <code>n</code> element.</li> <li><code>right</code> key with an <code>Array[A]</code> containing the remaining elements of <code>arr</code>.</li> </ul> <p>Example <pre><code>xtr.arrays.splitAt([1, 2, 3, 4, 5], 3)\n</code></pre> Result <pre><code>{ left: [1, 2, 3], right: [4, 5] }\n</code></pre></p> <p></p>"},{"location":"xtr/arrays/#take","title":"take","text":"<p><code>take(arr: Array[A], n: Number): Array[A]</code></p> <p>Returns a new <code>Array</code> with the elements in <code>arry</code>, but only taking the first <code>n</code> elements.</p> <p>Example <pre><code>xtr.arrays.take([1, 2, 3, 4, 5], 3)\n</code></pre> Result <pre><code>[1, 2, 3]\n</code></pre></p> <p></p>"},{"location":"xtr/arrays/#takewhile","title":"takeWhile","text":"<p><code>takeWhile(arr: Array[A], predicate: Func[(A) =&gt; Boolean]): Array[A]</code></p> <p>Returns a new <code>Array</code> with the elements in <code>arr</code>, but only taking the first elements that satisfy the given <code>predicate</code>, which must accept an <code>A</code>.</p> <p>Example <pre><code>xtr.arrays.takeWhile([1, 2, 3, 4, 5], function(item) item * 2 &lt; 9)\n</code></pre> Result <pre><code>[1, 2, 3, 4]\n</code></pre></p> <p></p>"},{"location":"xtr/arrays/#unzip","title":"unzip","text":"<p><code>unzip(arr: Array[Array[A]]): Array[Array[A]]</code></p> <p>Create n-number of <code>Arrays</code>, each containing the n-th element of every array in <code>arr</code>.</p> <p>Returns a new <code>Array</code> of equal size to the shortest array in <code>arr</code>. Every n-th element in the result is an <code>Array</code> containing the n-th element the arrays in <code>arr</code>.</p> <p>Example <pre><code>xtr.arrays.unzip([[1, 'x'], [2, 'y'], [3, 'z']])\n</code></pre> Result <pre><code>[[1, 2, 3], ['x', 'y', 'z']]\n</code></pre></p> <p></p>"},{"location":"xtr/arrays/#zip","title":"zip","text":"<p><code>zip(arr1: Array[A], arr2: Array[B], arrN: Array[C]*): Array[Array[A|B|C]]</code></p> <p>Combines corresponding elements of the given arrays.</p> <p>Returns a new <code>Array</code> of equal size to the shortest array given. Every n-th element in the result is an <code>Array</code> containing the n-th element of the given arrays.</p> <p>Example <pre><code>xtr.arrays.zip([1, 2, 3], ['x', 'y', 'z'])\n</code></pre> Result <pre><code>[[1, 'x'], [2, 'y'], [3, 'z']]\n</code></pre></p>"},{"location":"xtr/base64/","title":"xtr.base64","text":""},{"location":"xtr/base64/#decode","title":"decode","text":"<p><code>decode(data: String): String</code></p> <p>Returns the Base64-decoded <code>data</code>.</p> <p>Example <pre><code>xtr.url.decode('SGVsbG8gV29ybGQ=')\n</code></pre> Result <pre><code>'Hello World'\n</code></pre></p> <p></p>"},{"location":"xtr/base64/#encode","title":"encode","text":"<p><code>encode(data: String): String</code></p> <p>Returns the Base64-encoded <code>data</code>.</p> <p>Example <pre><code>xtr.url.encode('Hello World')\n</code></pre> Result <pre><code>'SGVsbG8gV29ybGQ='\n</code></pre></p>"},{"location":"xtr/crypto/","title":"xtr.crypto","text":""},{"location":"xtr/crypto/#decrypt","title":"decrypt","text":"<p><code>decrypt(data: String, key: String, transformation: String): String</code></p> <p>Decrypts the Base64 <code>data</code> with specified Java Cryptographic <code>transformation</code> and the given <code>key</code>.</p> <p>The <code>transformation</code> must include the name of a cryptographic algorithm (e.g., AES), and may be followed by a feedback mode and padding scheme. A transformation is of the form: 'algorithm/mode/padding' or 'algorithm'. See the Java Cipher docs for more information.</p> <p>Example <pre><code>xtr.crypto.decrypt('vAkb3PWJPQF1kGkM3vQrdQ==', '$sixteencharkey$', 'AES/ECB/PKCS5Padding')\n</code></pre> Result <pre><code>'Hello, world!'\n</code></pre></p> <p>Note</p> <p>xtrasonnet supports decryption through the Java Cryptographic Extension (JCE) framework. Every Java distribution is required to support a specific set of algorithms, while others may only be supported by third party libraries such as the popular Bouncy Castle libraries, which are bundled with xtrasonnet.</p> <p>Note</p> <p>In order to facilitate encryption/decryption, xtrasonnet prefixes the encrypted data with the randomly generated initialization vector (IV) used by the JCE Cipher. Similarly, decryption operations expect such IV to be present in order to correctly decrypt the data.  </p> <p>The form of the payload byte array expected for decryption is as follows: <code>[{encryption IV bytes},{encrypted data bytes}]</code> where the size of the IV portion is equal to the block size for the selected algorithm.</p> <p></p>"},{"location":"xtr/crypto/#encrypt","title":"encrypt","text":"<p><code>encrypt(data: String, key: String, transformation: String): String</code></p> <p>Encrypts the <code>data</code> with specified Java Cryptographic <code>transformation</code> and the given <code>key</code>, and encodes the result in Base64.</p> <p>The <code>transformation</code> must include the name of a cryptographic algorithm (e.g., AES), and may be followed by a feedback mode and padding scheme. A transformation is of the form: 'algorithm/mode/padding' or 'algorithm'. See the Java Cipher docs for more information.</p> <p>Example <pre><code>xtr.crypto.encrypt('Hello, world!', '$sixteencharkey$', 'AES/ECB/PKCS5Padding')\n</code></pre> Result <pre><code>'vAkb3PWJPQF1kGkM3vQrdQ=='\n</code></pre></p> <p>Note</p> <p>xtrasonnet supports encryption through the Java Cryptographic Extension (JCE) framework. Every Java distribution is required to support a specific set of algorithms, while others may only be found in third party libraries such as the popular Bouncy Castle libraries, which are bundled with xtrasonnet.</p> <p>Note</p> <p>In order to facilitate encryption/decryption, xtrasonnet prefixes the encrypted data with the randomly generated initialization vector (IV) used by the JCE Cipher. Similarly decryption operations expect such IV to be present in order to correctly decrypt the data.  </p> <p>The form of the encrypted byte array payload is as follows: <code>[{random IV bytes},{encrypted data bytes}]</code> where the size of the IV portion is equal to the block size for the selected algorithm.</p> <p></p>"},{"location":"xtr/crypto/#hash","title":"hash","text":"<p><code>hash(data: String, algorithm: String): String</code></p> <p>Calculates Message Digest for the <code>data</code> using the given hash <code>algorithm</code>, and encodes the result in a hexadecimal string.</p> <p>Example <pre><code>xtr.crypto.hash('HelloWorld', 'MD5')\n</code></pre> Result <pre><code>'68e109f0f40ca72a15e05cc22786f8e6'\n</code></pre></p> <p>Note</p> <p>xtrasonnet supports Message Digests through the Java Security framework. Every Java distribution is required to support a specific set of algorithms, while others may only be supported by third party libraries. Users may be able to use an extended set of algorithms by adding any such library to the classpath.</p> <p></p>"},{"location":"xtr/crypto/#hmac","title":"hmac","text":"<p><code>hmac(data: String, key: String, algorithm: String): String</code></p> <p>Calculates the Message Authentication Code for the <code>data</code> using the given cryptographic hash <code>algorithm</code>, and encodes the result in a hexadecimal string.</p> <p>Example <pre><code>xtr.crypto.hmac('HelloWorld', 'xtrasonnet rules!', 'HMACSHA256')\n</code></pre> Result <pre><code>'7854220ef827b07529509f68f391a80bf87fff328dbda140ed582520a1372dc1'\n</code></pre></p> <p>Note</p> <p>xtrasonnet supports HMAC through the Java Security framework. Every Java distribution is required to support a specific set of algorithms, while others may only be supported by third party libraries. Users may be able to use an extended set of algorithms by adding any such library to the classpath.</p>"},{"location":"xtr/datetime/","title":"xtr.datetime","text":"<p>The datetime module leverages the ISO-8601 offset date-time format for representing and manipulating date and time, and the ISO-8601 duration format for temporal amounts. The ISO format is the recommendation of the IETF through RFC 3339: Date and Time on the Internet.</p> <p>Hint</p> <p>Users that need to operate on other date and time formats can use the <code>parse</code> function to convert it to the supported format, operate on the result, and optionally output it to any other format with the <code>format</code> function.</p>"},{"location":"xtr/datetime/#atbeginningofday","title":"atBeginningOfDay","text":"<p><code>atBeginningOfDay(datetime: String): String</code></p> <p>Returns the given <code>datetime</code> at midnight.</p> <p>Example <pre><code>xtr.datetime.atBeginningOfDay('2020-12-31T23:19:35Z')\n</code></pre> Result <pre><code>'2020-12-31T00:00:00Z'\n</code></pre></p> <p></p>"},{"location":"xtr/datetime/#atbeginningofhour","title":"atBeginningOfHour","text":"<p><code>atBeginningOfHour(datetime: String): String</code></p> <p>Returns the given <code>datetime</code> with the minutes and seconds set to zero.</p> <p>Example <pre><code>xtr.datetime.atBeginningOfHour('2020-12-31T23:19:35Z')\n</code></pre> Result <pre><code>'2020-12-31T23:00:00Z'\n</code></pre></p> <p></p>"},{"location":"xtr/datetime/#atbeginningofmonth","title":"atBeginningOfMonth","text":"<p><code>atBeginningOfMonth(datetime: String): String</code></p> <p>Returns the given <code>datetime</code> with the day set to first of the month, and the time set to midnight.</p> <p>Example <pre><code>xtr.datetime.atBeginningOfMonth('2020-12-31T23:19:35Z')\n</code></pre> Result <pre><code>'2020-12-01T00:00:00Z'\n</code></pre></p> <p></p>"},{"location":"xtr/datetime/#atbeginningofweek","title":"atBeginningOfWeek","text":"<p><code>atBeginningOfWeek(datetime: String): String</code></p> <p>Returns the given <code>datetime</code> with the day set to first of the current week, and the time set to midnight.</p> <p>Example <pre><code>xtr.datetime.atBeginningOfWeek('2020-12-31T23:19:35Z')\n</code></pre> Result <pre><code>'2020-12-27T00:00:00Z'\n</code></pre></p> <p></p>"},{"location":"xtr/datetime/#atbeginningofyear","title":"atBeginningOfYear","text":"<p><code>atBeginningOfYear(datetime: String): String</code></p> <p>Returns the given <code>datetime</code> with the day/month set to January 1st, and the time set to midnight.</p> <p>Example <pre><code>xtr.datetime.atBeginningOfYear('2020-12-31T23:19:35Z')\n</code></pre> Result <pre><code>'2020-01-01T00:00:00Z'\n</code></pre></p> <p></p>"},{"location":"xtr/datetime/#inoffset","title":"inOffset","text":"<p><code>inOffset(datetime: String, offset: String): String</code></p> <p>Returns the given <code>datetime</code> in the given timezone <code>offset</code>, changing the date and time as appropriate.</p> <p>Example <pre><code>xtr.datetime.inOffset('2020-12-31T23:19:35Z', '-08:00')\n</code></pre> Result <pre><code>'2020-12-31T15:19:35-08:00'\n</code></pre></p> <p></p>"},{"location":"xtr/datetime/#compare","title":"compare","text":"<p><code>compare(datetime1: String, datetime2: String): String</code></p> <p>Returns:</p> <p><code>1</code> if <code>datetime1</code> is after <code>datetime2</code></p> <p><code>-1</code> if <code>datetime1</code> is before <code>datetime2</code></p> <p><code>0</code> if <code>datetime1</code> and <code>datetime2</code> are the same</p> <p>Example <pre><code>xtr.datetime.compare('2020-12-31T23:19:35Z','2020-01-01T00:00:00Z')\n</code></pre> Result <pre><code>1\n</code></pre></p> <p></p>"},{"location":"xtr/datetime/#of","title":"of","text":"<p><code>of(parts: Object[Number|String]): String</code></p> <p>Returns the <code>String</code> representation of the date and time given in <code>parts</code>, an <code>Object</code> of the form:</p> <pre><code>{\n    year: Number, month: Number, day: Number,\n    hour: Number, minute: Number, second: Number,\n    offset: String\n}\n</code></pre> <p>where all elements are optional.</p> <p>Example <pre><code>local parts = {\n    'year': 2021,\n    'offset': '-08:00'\n};\n\nxtr.datetime.of(parts)\n</code></pre> Result <pre><code>'2021-01-01T00:00:00-08:00'\n</code></pre></p> <p></p>"},{"location":"xtr/datetime/#between","title":"between","text":"<p><code>between(datetime1: String, datetime2: String): String</code></p> <p>Returns the ISO-8601 duration between <code>datetime1</code> and <code>datetime2</code>.</p> <p>Example <pre><code>local date1 = '2019-09-20T18:53:41.425Z';\nlocal date2 = '2019-09-14T18:53:41.425Z';\n\nxtr.datetime.between(date1, date2)\n</code></pre> Result <pre><code>'-P6D'\n</code></pre></p> <p></p>"},{"location":"xtr/datetime/#format","title":"format","text":"<p><code>format(datetime: String, format: String): String</code></p> <p>Returns the given <code>datetime</code> formatted in the requested <code>format</code>.</p> <p>Example <pre><code>xtr.datetime.format('2019-09-20T18:53:41.425Z', 'yyyy/MM/dd')\n</code></pre> Result <pre><code>'2019/09/20'\n</code></pre></p> <p></p>"},{"location":"xtr/datetime/#isleapyear","title":"isLeapYear","text":"<p><code>isLeapYear(datetime: String): String</code></p> <p>Returns a <code>true</code> if <code>datetime</code> is in a leap year, otherwise <code>false</code>.</p> <p>Example <pre><code>xtr.datetime.isLeapYear('2019-09-14T18:53:41.425Z')\n</code></pre> Result <pre><code>false\n</code></pre></p> <p></p>"},{"location":"xtr/datetime/#minus","title":"minus","text":"<p><code>minus(datetime: String, duration: String): String</code></p> <p>Returns the result of subtracting the specified ISO-8601 <code>duration</code> from the given <code>datetime</code>.</p> <p>Example <pre><code>xtr.datetime.minus('2019-09-20T18:53:41Z', 'P2D')\n</code></pre> Result <pre><code>'2019-09-18T18:53:41Z'\n</code></pre></p> <p></p>"},{"location":"xtr/datetime/#now","title":"now","text":"<p><code>now(): String</code></p> <p>Returns the current datetime.</p> <p>Example <pre><code>xtr.datetime.now()\n</code></pre> Result <pre><code>'2021-01-05T13:09:45.476375-05:00'\n</code></pre></p> <p></p>"},{"location":"xtr/datetime/#parse","title":"parse","text":"<p><code>parse(datetime: String|Number, format: String): String</code></p> <p>Returns an ISO-8601 extended offset date-time from the given <code>datetime</code> using the specified <code>format</code>.</p> <p>Example <pre><code>xtr.datetime.parse('12/31/1990 10:10:10', 'MM/dd/yyyy HH:mm:ss')\n</code></pre> Result <pre><code>'1990-12-31T10:10:10Z'\n</code></pre></p> <p>Additionally, developers can parse Unix timestamps by passing <code>'unix'</code> as the <code>format</code>.</p> <p>Warning</p> <p>Date strings without a time offset or a time zone identifier will be defaulted to UTC time. If more control is needed, developers may add append time zone information before parsing.</p> <p></p>"},{"location":"xtr/datetime/#plus","title":"plus","text":"<p><code>plus(datetime: String, duration: String): String</code></p> <p>Returns the result of adding the specified ISO-8601 <code>duration</code> to the given <code>datetime</code>.</p> <p>Example <pre><code>xtr.datetime.plus('2019-09-18T18:53:41Z', 'P2D')\n</code></pre> Result <pre><code>'2019-09-20T18:53:41Z'\n</code></pre></p> <p></p>"},{"location":"xtr/datetime/#tolocaldate","title":"toLocalDate","text":"<p><code>toLocalDate(datetime: String): String</code></p> <p>Returns the given <code>datetime</code> without time or offset.</p> <p>Example <pre><code>xtr.datetime.toLocalDate('2019-07-04T18:53:41Z')\n</code></pre> Result <pre><code>'2019-07-04'\n</code></pre></p> <p></p>"},{"location":"xtr/datetime/#tolocaldatetime","title":"toLocalDateTime","text":"<p><code>toLocalDateTime(datetime: String): String</code></p> <p>Returns the given <code>datetime</code> without an offset.</p> <p>Example <pre><code>xtr.datetime.toLocalDateTime('2019-07-04T21:00:00Z')\n</code></pre> Result <pre><code>'2019-07-04T21:00:00'\n</code></pre></p> <p></p>"},{"location":"xtr/datetime/#tolocaltime","title":"toLocalTime","text":"<p><code>toLocalTime(datetime: String, format: String): String</code></p> <p>Returns the given <code>datetime</code> without date or offset.</p> <p>Example <pre><code>xtr.datetime.toLocalTime('2019-07-04T21:00:00Z')\n</code></pre> Result <pre><code>'21:00:00'\n</code></pre></p> <p></p>"},{"location":"xtr/datetime/#toparts","title":"toParts","text":"<p><code>toParts(datetime: String): Object[Number|String]</code></p> <p>Returns the constituent parts of the given <code>datetime</code>, as an <code>Object</code> of the form:</p> <pre><code>{\n    year: Number, month: Number, day: Number,\n    hour: Number, minute: Number, second: Number, nanosecond: Number,\n    offset: String\n}\n</code></pre> <p>Example <pre><code>xtr.datetime.toParts('2019-07-04T21:00:00Z')\n</code></pre> Result <pre><code>{\n    year: 2019, month: 7, day: 4,\n    hour: 21, minute: 0, second: 0, nanosecond: 0,\n    offset: 'Z'\n}\n</code></pre></p> <p></p>"},{"location":"xtr/datetime/#today","title":"today","text":"<p><code>today(): String</code></p> <p>Returns the current day at midnight.</p> <p>Example <pre><code>xtr.datetime.today\n</code></pre></p> <p>Result <pre><code>'2021-01-05T00:00:00-05:00'\n</code></pre></p> <p></p>"},{"location":"xtr/datetime/#tomorrow","title":"tomorrow","text":"<p><code>tomorrow(): String</code></p> <p>Returns the next day at midnight.</p> <p>Example <pre><code>xtr.datetime.tomorrow\n</code></pre></p> <p>Result <pre><code>'2021-01-06T00:00:00-05:00'\n</code></pre></p> <p></p>"},{"location":"xtr/datetime/#yesterday","title":"yesterday","text":"<p><code>yesterday(): String</code></p> <p>Returns the previous day at midnight.</p> <p>Example <pre><code>xtr.datetime.yesterday\n</code></pre></p> <p>Result <pre><code>'2021-01-04T00:00:00-05:00'\n</code></pre></p>"},{"location":"xtr/duration/","title":"xtr.duration","text":"<p>The duration module leverages the ISO-8601 duration format.</p>"},{"location":"xtr/duration/#of","title":"of","text":"<p><code>of(parts: Object[Number]): String</code></p> <p>Returns the ISO-8601 duration of the given <code>parts</code>, an <code>Object</code> of the form:</p> <pre><code>{\n    years: Number, months: Number, days: Number,\n    hours: Number, minutes: Number, seconds: Number\n}\n</code></pre> <p>where all elements are optional.</p> <p>Example <pre><code>local parts = {\n    years: 20, months: 3, days: 1,\n    hours: 12, minutes: 30, seconds: 45\n};\n\nxtr.duration.of(parts)\n</code></pre> Result <pre><code>'P20Y3M1DT12H30M45S'\n</code></pre></p> <p></p>"},{"location":"xtr/duration/#toparts","title":"toParts","text":"<p><code>toParts(duration: String): Object[Number]</code></p> <p>Returns the constituent parts of the given <code>duration</code>, as an <code>Object</code> of the form:</p> <pre><code>{\n    years: Number, months: Number, days: Number,\n    hours: Number, minutes: Number, seconds: Number\n}\n</code></pre> <p>Example <pre><code>xtr.duration.toParts('P20Y3M1DT12H30M45S')\n</code></pre> Result <pre><code>{\n    years: 20, months: 3, days: 1,\n    hours: 12, minutes: 30, seconds: 45\n}\n</code></pre></p>"},{"location":"xtr/math/","title":"xtr.math","text":""},{"location":"xtr/math/#abs","title":"abs","text":"<p><code>abs(num: Number): Number</code></p> <p>Returns the absolute value of the given <code>num</code>.</p> <p>Example <pre><code>xtr.math.abs(-1)\n</code></pre> Result <pre><code>1\n</code></pre></p> <p></p>"},{"location":"xtr/math/#acos","title":"acos","text":"<p><code>acos(num: Number): Number</code></p> <p>Returns the arc cosine of the given <code>num</code>.</p> <p>Example <pre><code>xtr.math.acos(1)\n</code></pre> Result <pre><code>0\n</code></pre></p> <p></p>"},{"location":"xtr/math/#asin","title":"asin","text":"<p><code>asin(num: Number): Number</code></p> <p>Returns the arc sine of the given <code>num</code>.</p> <p>Example <pre><code>xtr.math.asin(1)\n</code></pre> Result <pre><code>1.5707963267948966\n</code></pre></p> <p></p>"},{"location":"xtr/math/#atan","title":"atan","text":"<p><code>atan(num: Number): Number</code></p> <p>Returns the arc tangent of the given <code>num</code>.</p> <p>Example <pre><code>xtr.math.atan(1)\n</code></pre> Result <pre><code>0.7853981633974483\n</code></pre></p> <p></p>"},{"location":"xtr/math/#avg","title":"avg","text":"<p><code>avg(arr: Array[Number]): Number</code></p> <p>Returns the average of the numbers in <code>arr</code>.</p> <p>Example <pre><code>xtr.math.avg([1,2,3])\n</code></pre> Result <pre><code>2\n</code></pre></p> <p></p>"},{"location":"xtr/math/#ceil","title":"ceil","text":"<p><code>ceil(num: Number): Number</code></p> <p>Returns the ceiling (aka round up) of the given <code>num</code>.</p> <p>Example <pre><code>xtr.math.ceil(1.01)\n</code></pre> Result <pre><code>2\n</code></pre></p> <p></p>"},{"location":"xtr/math/#clamp","title":"clamp","text":"<p><code>clamp(num: Number, min: Number, max: Number): Number</code></p> <p>Returns <code>num</code> if it exists between <code>min</code> and <code>max</code>, otherwise the one that is closest.</p> <p>Example <pre><code>xtr.math.clamp(100, 0, 10)\n</code></pre> Result <pre><code>10\n</code></pre></p> <p></p>"},{"location":"xtr/math/#cos","title":"cos","text":"<p><code>cos(num: Number): Number</code></p> <p>Returns the cosine of the given<code>num</code>.</p> <p>Example <pre><code>xtr.math.cos(0)\n</code></pre> Result <pre><code>1\n</code></pre></p> <p></p>"},{"location":"xtr/math/#exp","title":"exp","text":"<p><code>exp(num: Number): Number</code></p> <p>Returns Euler's number e, to the power of <code>num</code>.</p> <p>Example <pre><code>xtr.math.exp(2)\n</code></pre> Result <pre><code>7.38905609893065\n</code></pre></p> <p></p>"},{"location":"xtr/math/#exponent","title":"exponent","text":"<p><code>exponent(num: Number): Number</code></p> <p>Returns the exponent portion of the double-precision binary floating-point representation (IEEE 754:binary64) of the given <code>num</code>.</p> <p>Example <pre><code>xtr.math.exponent(2)\n</code></pre> Result <pre><code>2\n</code></pre></p> <p></p>"},{"location":"xtr/math/#floor","title":"floor","text":"<p><code>floor(num: Number): Number</code></p> <p>Returns the floor (aka round down) of the given <code>num</code>.</p> <p>Example <pre><code>xtr.math.floor(4.99)\n</code></pre> Result <pre><code>4\n</code></pre></p> <p></p>"},{"location":"xtr/math/#log","title":"log","text":"<p><code>log(num: Number): Number</code></p> <p>Returns the natural logarithm of the given <code>num</code>.</p> <p>Example <pre><code>xtr.math.log(2)\n</code></pre> Result <pre><code>0.6931471805599453\n</code></pre></p> <p></p>"},{"location":"xtr/math/#mantissa","title":"mantissa","text":"<p><code>mantissa(num: Number): Number</code></p> <p>Returns the fraction portion (aka significand) of the double-precision binary floating-point representation (IEEE 754:binary64) of the given <code>num</code>.</p> <p>Example <pre><code>xtr.math.mantissa(2)\n</code></pre> Result <pre><code>0.5\n</code></pre></p> <p></p>"},{"location":"xtr/math/#pow","title":"pow","text":"<p><code>pow(num: Number1, num: Number2)</code></p> <p>Returns the value of <code>num1</code> raised to the power of <code>num2</code>.</p> <p>Example <pre><code>xtr.math.pow(2, 2)\n</code></pre> Result <pre><code>4\n</code></pre></p> <p></p>"},{"location":"xtr/math/#random","title":"random","text":"<p><code>random</code></p> <p>Returns a pseudo-random double-precision floating-point number between <code>0</code> and <code>1</code>.</p> <p>Example <pre><code>xtr.math.random\n</code></pre> Result <pre><code>0.5963038027787421\n</code></pre></p> <p></p>"},{"location":"xtr/math/#randomint","title":"randomInt","text":"<p><code>randomInt(num: Number): Number</code></p> <p>Returns a pseudo-random integer between 0 (inclusive) and the given<code>num</code> (exclusive).</p> <p>Example <pre><code>xtr.math.randomInt(500)\n</code></pre> Result <pre><code>485\n</code></pre></p> <p></p>"},{"location":"xtr/math/#round","title":"round","text":"<p><code>round(num: Number, mode: String = 'half-up', precision: Number = '0'): Number</code></p> <p>Rounds the given <code>num</code> using the <code>mode</code> and <code>precision</code> requested. Supported modes are <code>up</code>, <code>down</code>, <code>half-up</code>, <code>half-down</code>, <code>ceiling</code>, <code>floor</code>, and <code>half-even</code>.</p> <p>Example <pre><code>xtr.math.round(2.5)\n</code></pre> Result <pre><code>3\n</code></pre></p> <p></p>"},{"location":"xtr/math/#sin","title":"sin","text":"<p><code>sin(num: Number): Number</code></p> <p>Returns the sine of the given <code>num</code>.</p> <p>Example <pre><code>xtr.math.sin(1)\n</code></pre> Result <pre><code>0.8414709848078965\n</code></pre></p> <p></p>"},{"location":"xtr/math/#sqrt","title":"sqrt","text":"<p><code>sqrt(num: Number): Number</code></p> <p>Returns the square root of the given <code>num</code>.</p> <p>Example <pre><code>xtr.math.sqrt(4)\n</code></pre> Result <pre><code>2\n</code></pre></p> <p></p>"},{"location":"xtr/math/#sum","title":"sum","text":"<p><code>sum(arr: Array[Number])</code></p> <p>Returns the sum of all numbers in <code>arr</code>.</p> <p>Example <pre><code>xtr.math.sum([10, 20, 30])\n</code></pre> Result <pre><code>60\n</code></pre></p> <p></p>"},{"location":"xtr/math/#tan","title":"tan","text":"<p><code>tan(num: Number): Number</code></p> <p>Returns the tangent of the given <code>num</code>.</p> <p>Example <pre><code>xtr.math.tan(1)\n</code></pre> Result <pre><code>1.5574077246549023\n</code></pre></p>"},{"location":"xtr/numbers/","title":"xtr.numbers","text":""},{"location":"xtr/numbers/#ofbinary","title":"ofBinary","text":"<p><code>ofBinary(binary: String | Number): Number</code></p> <p>Returns the <code>Number</code> representation for the given <code>binary</code>.</p> <p>Example <pre><code>xtr.numbers.ofBinary(1100100)\n</code></pre> Result <pre><code>100\n</code></pre></p> <p></p>"},{"location":"xtr/numbers/#ofhex","title":"ofHex","text":"<p><code>ofHex(hexadecimal: String): Number</code></p> <p>Returns the <code>Number</code> representation for the given <code>hexadecimal</code>.</p> <p>Example <pre><code>xtr.numbers.ofHex('F')\n</code></pre> Result <pre><code>15\n</code></pre></p> <p></p>"},{"location":"xtr/numbers/#ofoctal","title":"ofOctal","text":"<p><code>ofOctal(octal: String | Number): Number</code></p> <p>Returns the <code>Number</code> representation for the given <code>octal</code>.</p> <p>Example <pre><code>xtr.numbers.ofOctal(107136)\n</code></pre> Result <pre><code>36446\n</code></pre></p> <p></p>"},{"location":"xtr/numbers/#ofradix","title":"ofRadix","text":"<p><code>ofRadix(value: String | Number, n: Number): Number</code></p> <p>Returns the <code>Number</code> representation for the given Base-<code>n</code> <code>value</code></p> <p>Example <pre><code>xtr.numbers.ofRadixNumber('10', 3)\n</code></pre> Result <pre><code>3\n</code></pre></p> <p></p>"},{"location":"xtr/numbers/#tobinary","title":"toBinary","text":"<p><code>toBinary(number: Number): String</code></p> <p>Returns the binary representation for the given <code>number</code>.</p> <p>Example <pre><code>xtr.numbers.toBinary(100)\n</code></pre> Result <pre><code>'1100100'\n</code></pre></p> <p></p>"},{"location":"xtr/numbers/#tohex","title":"toHex","text":"<p><code>toHex(number: Number): String</code></p> <p>Returns the hexadecimal representation for the given <code>number</code>.</p> <p>Example <pre><code>xtr.numbers.toHex(15)\n</code></pre> Result <pre><code>'F'\n</code></pre></p> <p></p>"},{"location":"xtr/numbers/#tooctal","title":"toOctal","text":"<p><code>toOctal(number: Number): String</code></p> <p>Returns the octal representation for the given <code>number</code>.</p> <p>Example <pre><code>xtr.numbers.toOctal(36446)\n</code></pre> Result <pre><code>'107136'\n</code></pre></p> <p></p>"},{"location":"xtr/numbers/#toradix","title":"toRadix","text":"<p><code>toRadix(value: Number, n: Number): String</code></p> <p>Returns the Base-<code>n</code> representation for the given <code>value</code> as a <code>String</code>.</p> <p>Example <pre><code>xtr.numbers.toRadix('3', 3)\n</code></pre> Result <pre><code>'10'\n</code></pre></p>"},{"location":"xtr/objects/","title":"xtr.objects","text":""},{"location":"xtr/objects/#all","title":"all","text":"<p><code>all(obj, Object[A], predicate: Func[(A, String) =&gt; Boolean]): Boolean</code></p> <p>Returns <code>true</code> if all entries in <code>obj</code> satisfy the given <code>predicate</code>, otherwise <code>false</code>. <code>predicate</code> must accept an <code>A</code> and its corresponding <code>String</code> key.</p> <p>Example <pre><code>local languages = {\n    scala: { version: '3.1.3', isJvm: true },\n    java: { version: '19', isJvm: true },\n    python: { version: '3.10.4', isJvm: false }\n};\n\nxtr.objects.all(languages, function(lang, name) lang.isJvm)\n</code></pre> Result <pre><code>false\n</code></pre></p> <p></p>"},{"location":"xtr/objects/#any","title":"any","text":"<p><code>any(obj, Object[A], predicate: Func[(A, String) =&gt; Boolean]): Boolean</code></p> <p>Returns <code>true</code> if any entry in <code>obj</code> satisfies the given <code>predicate</code>, otherwise <code>false</code>. <code>predicate</code> must accept an <code>A</code> and its corresponding <code>String</code> key.</p> <p>Example <pre><code>local languages = {\n    scala: { version: '3.1.3', isJvm: true },\n    java: { version: '19', isJvm: true },\n    python: { version: '3.10.4', isJvm: false }\n};\n\nxtr.objects.any(languages, function(lang, name) lang.isJvm)\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/objects/#distinctby","title":"distinctBy","text":""},{"location":"xtr/objects/#distinctby-funcvalue","title":"distinctBy func(value)","text":"<p><code>distinctBy(obj: Object[A], Func[(A) =&gt; B]): Object[A]</code></p> <p>Returns a new <code>Object</code> with the distinct entries in <code>obj</code> using the given <code>identity</code> function for comparison. <code>identity</code> must accept an <code>A</code>.</p> <p>Example <pre><code>local languages = {\n    first: { name: 'scala', version: '3.1.3', isJvm: true },\n    second: { name: 'java', version: '19', isJvm: true },\n    third: { name: 'java', version: '18', isJvm: true }\n};\n\nxtr.objects.distinctBy(languages, function(lang) lang.name)\n</code></pre> Result <pre><code>{\n    first: { name: 'scala', version: '3.1.3', isJvm: true },\n    second: { name: 'java', version: '19', isJvm: true }\n}\n</code></pre></p> <p></p>"},{"location":"xtr/objects/#distinctby-funcvalue-key","title":"distinctBy func(value, key)","text":"<p><code>distinctBy(obj: Object[A], Func[(A, String) =&gt; B]): Object[A]</code></p> <p>Returns a new <code>Object</code> with the distinct entries in <code>obj</code> using the given <code>identity</code> function for comparison. <code>identity</code> must accept an <code>A</code> and its corresponding <code>String</code> key.</p> <p>Example <pre><code>local languages = {\n    first: { name: 'scala', version: '3.1.3', isJvm: true },\n    second: { name: 'java', version: '19', isJvm: true },\n    third: { name: 'java', version: '18', isJvm: true }\n};\n\nxtr.objects.distinctBy(languages, function(lang, ordinal)\n    if (lang.name == 'java') then lang.version\n    else ordinal\n)\n</code></pre> Result <pre><code>{\n    first: { name: 'scala', version: '3.1.3', isJvm: true },\n    second: { name: 'java', version: '19', isJvm: true },\n    third: { name: 'java', version: '18', isJvm: true }\n}\n</code></pre></p> <p></p>"},{"location":"xtr/objects/#fromarray","title":"fromArray","text":""},{"location":"xtr/objects/#fromarray-funcvalue","title":"fromArray func(value)","text":"<p><code>fromArray(arr: Array[A], Func[(A) =&gt; Object[B]): Object[B]</code></p> <p>Returns a new <code>Object[B]</code> containing the entry of every <code>Object[B]</code> obtained by applying the given <code>function</code> to all elements in <code>arr</code>. <code>function</code> must accept an <code>A</code> value.</p> <p></p>"},{"location":"xtr/objects/#fromarray-funcvalue-idx","title":"fromArray func(value, idx)","text":"<p><code>fromArray(arr: Array[A], Func[(A, Number) =&gt; Object[B]]: Object[B]</code></p> <p>Returns a new <code>Object[B]</code> containing the entry of every <code>Object[B]</code> obtained by applying the given <code>function</code> to all elements in <code>arr</code>. <code>function</code> must accept an <code>A</code> value and its <code>Number</code> index.</p> <p></p>"},{"location":"xtr/objects/#fulleqjoin","title":"fullEqJoin","text":""},{"location":"xtr/objects/#fulleqjoin_1","title":"fullEqJoin","text":"<p><code>fullEqJoin(arrL: Array[Object[A]], arrR: Array[Object[B]], identity: Func[(Object[A]) =&gt; String|Number|Boolean], identityR: Func[(Object[B]) =&gt; String|Number|Boolean) =&gt; Object[C]]): Array[Object[C]]</code></p> <p>Returns a new <code>Array</code> with all the objects that exist in <code>arrL</code> or in <code>arrR</code>, joining those that exist in both with a shallow merge, and using the given <code>identity</code> functions to compute equality.</p> <p>Example <pre><code>local customers = [\n    { id: 2, email: 'joe@example.com', joined: '2021-07-30' },\n    { id: 77, email: 'jane@example.com', joined: '2019-07-30' },\n    { id: 17, email: 'john@example.com', joined: '2002-07-03' }\n];\n\nlocal orders = [\n    { orderId: 10308, customerId: 2, date: '2022-07-30' },\n    { orderId: 10309, customerId: 2, date: '2022-07-30' },\n    { orderId: 10310, customerId: 77, date: '2022-07-03' },\n    { orderId: 10311, customerId: 93, date: '2021-05-03' }\n];\n\nxtr.objects.fullEqJoin(customers, orders,\n    function(cust) cust.id, function(order) order.customerId)\n</code></pre> Result <pre><code>[\n    { id: 2, email: 'joe@example.com', joined: '2021-07-30',\n        orderId: 10308, customerId: 2, date: '2022-07-30' },\n    { id: 2, email: 'joe@example.com', joined: '2021-07-30',\n        orderId: 10309, customerId: 2, date: '2022-07-30' },\n    { id: 77, email: 'jane@example.com', joined: '2019-07-30',\n        orderId: 10310, customerId: 77, date: '2022-07-03' },\n    { id: 17, email: 'john@example.com', joined: '2002-07-03' },\n    { orderId: 10311, customerId: 93, date: '2021-05-03' }\n]\n</code></pre></p> <p></p>"},{"location":"xtr/objects/#fulleqjoin-funcleft-right-joined","title":"fullEqJoin func(left, right) =&gt; joined","text":"<p><code>fullEqJoin(arrL: Array[Object[A]], arrR: Array[Object[B]], identity: Func[(Object[A]) =&gt; String|Number|Boolean], identityR: Func[(Object[B]) =&gt; String|Number|Boolean)score], join: Func[(Object[A], Object[B]) =&gt; Object[C]]): Array[Object[C]]</code></p> <p>Returns a new <code>Array</code> with all the objects that exist in <code>arrL</code> or in <code>arrR</code>, joining those that exist in both with the given <code>join</code> function, and using the given <code>identity</code> functions to compute equality.</p> <p>Example <pre><code>local customers = [\n    { id: 2, email: 'joe@example.com', joined: '2021-07-30' },\n    { id: 77, email: 'jane@example.com', joined: '2019-07-30' },\n    { id: 17, email: 'john@example.com', joined: '2002-07-03' }\n];\n\nlocal orders = [\n    { orderId: 10308, customerId: 2, date: '2022-07-30' },\n    { orderId: 10309, customerId: 2, date: '2022-07-30' },\n    { orderId: 10310, customerId: 77, date: '2022-07-03' },\n    { orderId: 10311, customerId: 93, date: '2021-05-03' }\n];\n\nxtr.objects.fullEqJoin(customers, orders,\n    function(cust) cust.id, function(order) order.customerId,\n    function(cust, order) { id: cust?.id, oId: order?.orderId })\n</code></pre> Result <pre><code>[\n    { id: 2, oId: 10308 },\n    { id: 2, oId: 10309 },\n    { id: 77, oId: 10310 },\n    { id: 17, oId: null },\n    { id: null, oId: 10311 }\n]\n</code></pre></p> <p></p>"},{"location":"xtr/objects/#innereqjoin","title":"innerEqJoin","text":""},{"location":"xtr/objects/#innereqjoin_1","title":"innerEqJoin","text":"<p><code>innerEqJoin(arrL: Array[Object[A]], arrR: Array[Object[B]], identity: Func[(Object[A]) =&gt; String|Number|Boolean], identityR: Func[(Object[B]) =&gt; String|Number|Boolean)]): Array[Object[C]]</code></p> <p>Returns a new <code>Array</code> with all the objects that exist in both <code>arrL</code> and <code>arrR</code>, using the given <code>identity</code> functions to compute equality, and joined using a shallow merge.</p> <p>Example <pre><code>local customers = [\n    { id: 2, email: 'joe@example.com', joined: '2021-07-30' },\n    { id: 77, email: 'jane@example.com', joined: '2019-07-30' },\n    { id: 17, email: 'john@example.com', joined: '2002-07-03' }\n];\n\nlocal orders = [\n    { orderId: 10308, customerId: 2, date: '2022-07-30' },\n    { orderId: 10309, customerId: 2, date: '2022-07-30' },\n    { orderId: 10310, customerId: 77, date: '2022-07-03' },\n    { orderId: 10311, customerId: 93, date: '2021-05-03' }\n];\n\nxtr.objects.innerEqJoin(customers, orders,\n    function(cust) cust.id, function(order) order.customerId)\n</code></pre> Result <pre><code>[\n    { id: 2, email: 'joe@example.com', joined: '2021-07-30',\n        orderId: 10308, customerId: 2, date: '2022-07-30' },\n    { id: 2, email: 'joe@example.com', joined: '2021-07-30',\n        orderId: 10309, customerId: 2, date: '2022-07-30' },\n    { id: 77, email: 'jane@example.com', joined: '2019-07-30',\n        orderId: 10310, customerId: 77, date: '2022-07-03' }\n]\n</code></pre></p> <p></p>"},{"location":"xtr/objects/#innereqjoin-funcleft-right-joined","title":"innerEqJoin func(left, right) =&gt; joined","text":"<p><code>innerEqJoin(arrL: Array[Object[A]], arrR: Array[Object[B]], identity: Func[(Object[A]) =&gt; String|Number|Boolean], identityR: Func[(Object[B]) =&gt; String|Number|Boolean), join: Func[(Object[A], Object[B]) =&gt; Object[C]]): Array[Object[C]]</code></p> <p>Returns a new <code>Array</code> with all the objects that exist in both <code>arrL</code> and <code>arrR</code>, using the given <code>identity</code> functions to compute equality, and joined using the given <code>join</code> function.</p> <p>Example <pre><code>local customers = [\n    { id: 2, email: 'joe@example.com', joined: '2021-07-30' },\n    { id: 77, email: 'jane@example.com', joined: '2019-07-30' },\n    { id: 17, email: 'john@example.com', joined: '2002-07-03' }\n];\n\nlocal orders = [\n    { orderId: 10308, customerId: 2, date: '2022-07-30' },\n    { orderId: 10309, customerId: 2, date: '2022-07-30' },\n    { orderId: 10310, customerId: 77, date: '2022-07-03' },\n    { orderId: 10311, customerId: 93, date: '2021-05-03' }\n];\n\nxtr.objects.innerEqJoin(customers, orders,\n    function(cust) cust.id, function(order) order.customerId,\n    function(cust, order) { id: cust.id, oId: order.orderId })\n</code></pre> Result <pre><code>[\n    { id: 2, oId: 10308 },\n    { id: 2, oId: 10309 },\n    { id: 77, oId: 10310 }\n]\n</code></pre></p> <p></p>"},{"location":"xtr/objects/#lefteqjoin","title":"leftEqJoin","text":""},{"location":"xtr/objects/#lefteqjoin-funcleft-right-joined","title":"leftEqJoin func(left, right) =&gt; joined","text":"<p><code>leftEqJoin(arrL: Array[Object[A]], arrR: Array[Object[B]], identity: Func[(Object[A]) =&gt; String|Number|Boolean], identityR: Func[(Object[B]) =&gt; String|Number|Boolean)]): Array[Object[C]]</code></p> <p>Returns a new <code>Array</code> with all the objects that exist in <code>arrL</code>, joined using a shallow merge with those that also exist in <code>arrR</code>, using the given <code>identity</code> functions to compute equality.</p> <p>Example <pre><code>local customers = [\n    { id: 2, email: 'joe@example.com', joined: '2021-07-30' },\n    { id: 77, email: 'jane@example.com', joined: '2019-07-30' },\n    { id: 17, email: 'john@example.com', joined: '2002-07-03' }\n];\n\nlocal orders = [\n    { orderId: 10308, customerId: 2, date: '2022-07-30' },\n    { orderId: 10309, customerId: 2, date: '2022-07-30' },\n    { orderId: 10310, customerId: 77, date: '2022-07-03' },\n    { orderId: 10311, customerId: 93, date: '2021-05-03' }\n];\n\nxtr.objects.leftEqJoin(customers, orders,\n    function(cust) cust.id, function(order) order.customerId)\n</code></pre> Result <pre><code>[\n    { id: 2, email: 'joe@example.com', joined: '2021-07-30',\n        orderId: 10308, customerId: 2, date: '2022-07-30' },\n    { id: 2, email: 'joe@example.com', joined: '2021-07-30',\n        orderId: 10309, customerId: 2, date: '2022-07-30' },\n    { id: 77, email: 'jane@example.com', joined: '2019-07-30',\n        orderId: 10310, customerId: 77, date: '2022-07-03' },\n    { id: 17, email: 'john@example.com', joined: '2002-07-03' }\n]\n</code></pre></p> <p></p>"},{"location":"xtr/objects/#lefteqjoin-funcleft-right-joined_1","title":"leftEqJoin func(left, right) =&gt; joined","text":"<p><code>leftEqJoin(arrL: Array[Object[A]], arrR: Array[Object[B]], identity: Func[(Object[A]) =&gt; String|Number|Boolean], identityR: Func[(Object[B]) =&gt; String|Number|Boolean), join: Func[(Object[A], Object[B]) =&gt; Object[C]]): Array[Object[C]]</code></p> <p>Returns a new <code>Array</code> with all the objects that exist in <code>arrL</code>, joined using the given <code>join</code> function with those that also exist in <code>arrR</code>, using the given <code>identity</code> functions to compute equality.</p> <p>Example <pre><code>local customers = [\n    { id: 2, email: 'joe@example.com', joined: '2021-07-30' },\n    { id: 77, email: 'jane@example.com', joined: '2019-07-30' },\n    { id: 17, email: 'john@example.com', joined: '2002-07-03' }\n];\n\nlocal orders = [\n    { orderId: 10308, customerId: 2, date: '2022-07-30' },\n    { orderId: 10309, customerId: 2, date: '2022-07-30' },\n    { orderId: 10310, customerId: 77, date: '2022-07-03' },\n    { orderId: 10311, customerId: 93, date: '2021-05-03' }\n];\n\nxtr.objects.leftEqJoin(customers, orders,\n    function(cust) cust.id, function(order) order.customerId,\n    function(cust, order) { id: cust.id, oId: order?.orderId })\n</code></pre> Result <pre><code>[\n    { id: 2, oId: 10308 },\n    { id: 2, oId: 10309 },\n    { id: 77, oId: 10310 },\n    { id: 17, oId: null }\n]\n</code></pre></p>"},{"location":"xtr/strings/","title":"xtr.strings","text":""},{"location":"xtr/strings/#appendifmissing","title":"appendIfMissing","text":"<p><code>appendIfMissing(str: String, suffix: String): String</code></p> <p>Returns <code>str</code>, appended with <code>suffix</code> if it does not already end with <code>suffix</code>.</p> <p>Example <pre><code>xtr.strings.appendIfMissing('Hello', ' World')\n</code></pre> Result <pre><code>'Hello World'\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#capitalize","title":"capitalize","text":"<p><code>capitalize(str: String): String</code></p> <p>Returns the capitalized version of <code>str</code>, by capitalizing the first letter of every word.</p> <p>Example <pre><code>xtr.strings.capitalize('hello world')\n</code></pre> Result <pre><code>'Hello World'\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#charcode","title":"charCode","text":"<p><code>charCode(char: String): String</code></p> <p>Returns the character-code for the given <code>char</code>.</p> <p>Example <pre><code>xtr.strings.charCode('*')\n</code></pre> Result <pre><code>42\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#charcodeat","title":"charCodeAt","text":"<p><code>charCodeAt(str: String, index: Number): String</code></p> <p>Returns the character-code for the character at the given <code>index</code> in <code>str</code>.</p> <p>Example <pre><code>xtr.strings.charCodeAt('_*_', 1)\n</code></pre> Result <pre><code>42\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#ofcharcode","title":"ofCharCode","text":"<p><code>ofCharCode(code: Number): String</code></p> <p>Returns the character for the given character-code.</p> <p>Example <pre><code>xtr.strings.ofCharCode(42)\n</code></pre> Result <pre><code>'*'\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#isalpha","title":"isAlpha","text":"<p><code>isAlpha(str: String): String</code></p> <p>Returns <code>true</code> if the given <code>str</code> contains only alphabetic characters, otherwise <code>false</code>.</p> <p>Example <pre><code>xtr.strings.isAlpha('abcde')\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#isalphanumeric","title":"isAlphanumeric","text":"<p><code>isAlphanumeric(str: String): String</code></p> <p>Returns <code>true</code> if the given <code>str</code> contains only alphanumeric characters, otherwise <code>false</code>.</p> <p>Example <pre><code>xtr.strings.isAlphanumeric('a1b2cd3e4')\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#islowercase","title":"isLowerCase","text":"<p><code>isLowerCase(str: String): String</code></p> <p>Returns <code>true</code> if the alphabetic characters in the given <code>str</code> are all lowercase, otherwise <code>false</code>.</p> <p>Example <pre><code>xtr.strings.isLowerCase('hello')\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#isnumeric","title":"isNumeric","text":"<p><code>isNumeric(str: String): String</code></p> <p>Returns <code>true</code> if the given <code>str</code> contains only numeric characters.</p> <p>Example <pre><code>xtr.strings.isNumeric('34634')\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#isuppercase","title":"isUpperCase","text":"<p><code>isUpperCase(str: String): String</code></p> <p>Returns <code>true</code> if the alphabetic characters in the given <code>str</code> are all uppercse, otherwise <code>false</code>.</p> <p>Example <pre><code>xtr.strings.isUpperCase('HELLO')\n</code></pre> Result <pre><code>true\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#leftpad","title":"leftPad","text":"<p><code>leftPad(str: String, size: Number, char: String): String</code></p> <p>Returns <code>str</code> prepended with enough repetitions of <code>char</code> required to meet the given <code>size</code>, otherwise returns <code>str</code> if its size is already equal or longer than <code>size</code>.</p> <p>Example <pre><code>xtr.strings.leftPad('Hello', 10, ' ')\n</code></pre> Result <pre><code>'     Hello'\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#numordinalof","title":"numOrdinalOf","text":"<p><code>numOrdinalOf(num: Number): String</code></p> <p>Returns the numeric ordinal name for the given <code>num</code>.</p> <p>Example <pre><code>xtr.strings.numOrdinalOf(1)\n</code></pre> Result <pre><code>'1st'\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#pluralize","title":"pluralize","text":"<p><code>pluralize(word: String): String</code></p> <p>Returns the plural of the given <code>word</code>.</p> <p>Example <pre><code>xtr.strings.pluralize('car')\n</code></pre> Result <pre><code>'cars'\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#prependifmissing","title":"prependIfMissing","text":"<p><code>prependIfMissing(str: String, prefix: String): String</code></p> <p>Returns <code>str</code>, prepended with <code>prefix</code> if it does not already start with <code>prefix</code>.</p> <p>Example <pre><code>xtr.strings.prependIfMissing('World', 'Hello ')\n</code></pre> Result <pre><code>'Hello World'\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#repeat","title":"repeat","text":"<p><code>repeat(str: String, n: Number): String</code></p> <p>Returns <code>str</code> repeated <code>n</code> times.</p> <p>Example <pre><code>xtr.strings.repeat('hey ', 2)\n</code></pre> Result <pre><code>'hey hey '\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#rightpad","title":"rightPad","text":"<p><code>rightPad(str: String, size: Number, char: String): String</code></p> <p>Returns <code>str</code> prepended with enough repetitions of <code>char</code> required to meet the given <code>size</code>, otherwise returns <code>str</code> if its size is already equal or longer than <code>size</code>.</p> <p>Example <pre><code>xtr.strings.rightPad('Hello', 10, ' ')\n</code></pre> Result <pre><code>'Hello     '\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#singularize","title":"singularize","text":"<p><code>singularize(word: String): String</code></p> <p>Returns the singular of the given <code>word</code>.</p> <p>Example <pre><code>xtr.strings.singularize('cars')\n</code></pre> Result <pre><code>'car'\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#substringafter","title":"substringAfter","text":"<p><code>substringAfter(str1: String, str2: String): String</code></p> <p>Returns the contents of <code>str1</code> after the first occurrence of <code>str2</code>, otherwise returns <code>str1</code> if it does not contain <code>str2</code>.</p> <p>Example <pre><code>xtr.strings.substringAfter('!XHelloXWorldXAfter', 'X')\n</code></pre> Result <pre><code>'HelloXWorldXAfter'\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#substringafterlast","title":"substringAfterLast","text":"<p><code>substringAfterLast(str1: String, str2: String): String</code></p> <p>Returns the contents of <code>str1</code> after the last occurrence of <code>str2</code>, otherwise returns <code>str1</code> if it does not contain <code>str2</code>.</p> <p>Example <pre><code>xtr.strings.substringAfterLast('!XHelloXWorldXAfter', 'X')\n</code></pre> Result <pre><code>'After'\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#substringbefore","title":"substringBefore","text":"<p><code>substringBefore(str1: String, str2: String): String</code></p> <p>Returns the contents of <code>str1</code> before the first occurrence of <code>str2</code>, otherwise returns <code>str1</code> if it does not contain <code>str2</code>.</p> <p>Example <pre><code>xtr.strings.substringBefore('!XHelloXWorldXAfter', 'X')\n</code></pre> Result <pre><code>'!'\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#substringbeforelast","title":"substringBeforeLast","text":"<p><code>substringBeforeLast(str1: String, str2: String): String</code></p> <p>Returns the contents of <code>str1</code> before the last occurrence of <code>str2</code>, otherwise returns <code>str1</code> if it does not contain <code>str2</code>.</p> <p>Example <pre><code>xtr.strings.substringBeforeLast('!XHelloXWorldXAfter', 'X')\n</code></pre> Result <pre><code>'!XHelloXWorld'\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#tocamelcase","title":"toCamelCase","text":"<p><code>toCamelCase(str: String): String</code></p> <p>Returns the toCamelCased version of <code>str</code>, by removing all spaces and underscores, and capitalizing the first letter of every word after the first.</p> <p>Example <pre><code>xtr.strings.toCamelCase('Hello to_everyone')\n</code></pre> Result <pre><code>'helloToEveryone'\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#tokebabcase","title":"toKebabCase","text":"<p><code>toKebabCase(str: String): String</code></p> <p>Returns the kebab-case version of <code>str</code>, by changing alphabetic characters to lowercase, and replacing all spaces and underscores for dashes.</p> <p>Example <pre><code>xtr.strings.toKebabCase('Hello World_X')\n</code></pre> Result <pre><code>'hello-world-x'\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#tosnakecase","title":"toSnakeCase","text":"<p><code>toSnakeCase(str: String): String</code></p> <p>Returns the snake_case version of the given <code>str</code>, by prepending uppercase characters with an underscore, changing alphabetic characters to lowercase, and replacing all spaces for underscores.</p> <p>Example <pre><code>xtr.strings.toSnakeCase('Hello WorldX')\n</code></pre> Result <pre><code>'hello_world_x'\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#unwrap","title":"unwrap","text":"<p><code>unwrap(str: String, wrap: String): String</code></p> <p>Returns <code>str</code> without the given <code>wrap</code> as prefix and suffix, if found.</p> <p>Example <pre><code>xtr.strings.unwrap('_Hello, world!_', '_')\n</code></pre> Result <pre><code>'Hello, world!'\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#wrap","title":"wrap","text":"<p><code>wrap(str: String, wrap: String): String</code></p> <p>Returns <code>str</code>, prepended and appended with <code>wrap</code>.</p> <p>Example <pre><code>xtr.strings.wrap('_Hello, world!', '_')\n</code></pre> Result <pre><code>'__Hello, world!_'\n</code></pre></p> <p></p>"},{"location":"xtr/strings/#wrapifmissing","title":"wrapIfMissing","text":"<p><code>wrapIfMissing(str: String, wrap: String): String</code></p> <p>Returns <code>str</code>, prepended and appended with <code>wrap</code>, if not found.</p> <p>Example <pre><code>xtr.strings.wrapIfMissing('_Hello, world!', '_')\n</code></pre> Result <pre><code>'_Hello, world!_'\n</code></pre></p>"},{"location":"xtr/url/","title":"xtr.url","text":""},{"location":"xtr/url/#decode","title":"decode","text":"<p><code>decode(data: String): String</code></p> <p>Returns the URL-decoded <code>data</code>.</p> <p>Example <pre><code>xtr.url.decode('Hello+World')\n</code></pre> Result <pre><code>'Hello World'\n</code></pre></p> <p></p>"},{"location":"xtr/url/#encode","title":"encode","text":"<p><code>encode(data: String): String</code></p> <p>Returns the URL-encoded <code>data</code>.</p> <p>Example <pre><code>xtr.url.encode('Hello World')\n</code></pre> Result <pre><code>'Hello+World'\n</code></pre></p>"}]}